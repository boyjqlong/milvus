// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package parser // MySqlParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MySqlParser struct {
	*antlr.BaseParser
}

var mysqlparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func mysqlparserParserInit() {
	staticData := &mysqlparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", "'BETWEEN'",
		"'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'",
		"'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'",
		"'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'",
		"'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", "'DATABASES'",
		"'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'", "'DESCRIBE'",
		"'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", "'DISTINCTROW'", "'DROP'",
		"'EACH'", "'ELSE'", "'ELSEIF'", "'EMPTY'", "'ENCLOSED'", "'ESCAPED'",
		"'EXCEPT'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'FALSE'", "'FETCH'",
		"'FOR'", "'FORCE'", "'FOREIGN'", "'FROM'", "'FULLTEXT'", "'GENERATED'",
		"'GET'", "'GRANT'", "'GROUP'", "'HAVING'", "'HIGH_PRIORITY'", "'HISTOGRAM'",
		"'IF'", "'IGNORE'", "'IGNORED'", "'IN'", "'INDEX'", "'INFILE'", "'INNER'",
		"'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'",
		"'JOIN'", "'KEY'", "'KEYS'", "'KILL'", "'LATERAL'", "'LEADING'", "'LEAVE'",
		"'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'",
		"'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'",
		"'MATCH'", "'MAXVALUE'", "'MINVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'",
		"'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'",
		"'OPTION'", "'OPTIONAL'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'",
		"'OUTER'", "'OUTFILE'", "'OVER'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'",
		"'PURGE'", "'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'",
		"'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'",
		"'RESTRICT'", "'RETAIN'", "'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'",
		"'SCHEMA'", "'SCHEMAS'", "'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'",
		"'SIGNAL'", "'SKIP'", "'SPATIAL'", "'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'",
		"'SQLWARNING'", "'SQL_BIG_RESULT'", "'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'",
		"'SSL'", "'STACKED'", "'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'",
		"'TABLE'", "'TERMINATED'", "'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'",
		"'TRUE'", "'UNDO'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'",
		"'UPDATE'", "'USAGE'", "'USE'", "'USING'", "'VALUES'", "'WHEN'", "'WHERE'",
		"'WHILE'", "'WITH'", "'WRITE'", "'XOR'", "'ZEROFILL'", "'TINYINT'",
		"'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'", "'INT'", "'INT1'", "'INT2'",
		"'INT3'", "'INT4'", "'INT8'", "'INTEGER'", "'BIGINT'", "'REAL'", "'DOUBLE'",
		"'PRECISION'", "'FLOAT'", "'FLOAT4'", "'FLOAT8'", "'DECIMAL'", "'DEC'",
		"'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'", "'DATETIME'", "'YEAR'",
		"'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'", "'BINARY'", "'VARBINARY'",
		"'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'", "'LONGBLOB'", "'TINYTEXT'",
		"'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'", "'ENUM'", "'VARYING'", "'SERIAL'",
		"'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'", "'DAY_SECOND'", "'HOUR_MINUTE'",
		"'HOUR_SECOND'", "'MINUTE_SECOND'", "'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'",
		"'HOUR_MICROSECOND'", "'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'",
		"'JSON_ARRAY_APPEND'", "'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'",
		"'JSON_DEPTH'", "'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", "'JSON_LENGTH'",
		"'JSON_MERGE'", "'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", "'JSON_OBJECT'",
		"'JSON_OBJECTAGG'", "'JSON_OVERLAPS'", "'JSON_PRETTY'", "'JSON_QUOTE'",
		"'JSON_REMOVE'", "'JSON_REPLACE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'",
		"'JSON_SEARCH'", "'JSON_SET'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'",
		"'JSON_TABLE'", "'JSON_TYPE'", "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'",
		"'NESTED'", "'ORDINALITY'", "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'",
		"'BIT_XOR'", "'COUNT'", "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'",
		"'GROUP_CONCAT'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'",
		"'NTILE'", "'NTH_VALUE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'",
		"'STD'", "'STDDEV'", "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'",
		"'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'LOCALTIME'", "'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'",
		"'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'",
		"'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'",
		"'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'",
		"'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'",
		"'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'",
		"'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'",
		"'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'",
		"'CLIENT'", "'CLOSE'", "'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'",
		"'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'",
		"'COMPLETION'", "'COMPRESSED'", "", "'CONCURRENT'", "'CONNECT'", "'CONNECTION'",
		"'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'",
		"'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'",
		"'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'",
		"'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'",
		"'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'",
		"'ENABLE'", "'ENCRYPTED'", "'ENCRYPTION'", "'ENCRYPTION_KEY_ID'", "'END'",
		"'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'",
		"'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'",
		"'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", "'FAILED_LOGIN_ATTEMPTS'",
		"'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'",
		"'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'", "'FOUND'", "'FULL'",
		"'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'",
		"'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'", "'HOST'", "'HOSTS'", "'IDENTIFIED'",
		"'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", "'INDEXES'", "'INITIAL_SIZE'",
		"'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'", "'INSTANT'",
		"'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'",
		"'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'",
		"'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'",
		"'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'",
		"'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'",
		"'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'",
		"'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'",
		"'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'",
		"'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'",
		"'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'",
		"'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", "'MIGRATE'",
		"'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", "'MYSQL_ERRNO'",
		"'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", "'NOCACHE'",
		"'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'", "'NOMINVALUE'", "'NOWAIT'",
		"'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'", "'OFFSET'", "'OF'",
		"'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'",
		"'OPTIONS'", "'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PAGE_COMPRESSED'",
		"'PAGE_COMPRESSION_LEVEL'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'",
		"'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'", "'PHASE'", "'PLUGIN'",
		"'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'", "'PRECEDING'",
		"'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", "'PROFILE'", "'PROFILES'",
		"'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", "'RECOVER'", "'RECURSIVE'",
		"'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'",
		"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'",
		"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'",
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'",
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'",
		"'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'REUSE'",
		"'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'",
		"'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'",
		"'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'",
		"'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'",
		"'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'",
		"'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'",
		"'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'",
		"'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'",
		"'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'",
		"'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'",
		"'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'",
		"'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'",
		"'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'",
		"'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
		"'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'",
		"'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'",
		"'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'",
		"'MICROSECOND'", "'ADMIN'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ADMIN'",
		"'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'",
		"'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'", "'FILE'",
		"'FIREWALL_ADMIN'", "'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'",
		"'FLUSH_TABLES'", "'FLUSH_USER_RESOURCES'", "'GROUP_REPLICATION_ADMIN'",
		"'INNODB_REDO_LOG_ARCHIVE'", "'INNODB_REDO_LOG_ENABLE'", "'INVOKE'",
		"'LAMBDA'", "'NDB_STORED_USER'", "'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'",
		"'PRIVILEGES'", "'PROCESS'", "'RELOAD'", "'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'",
		"'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "'ROUTINE'",
		"'S3'", "'SERVICE_CONNECTION_ADMIN'", "", "'SET_USER_ID'", "'SHOW_ROUTINE'",
		"'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLES'", "'TABLE_ENCRYPTION_ADMIN'",
		"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'",
		"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'",
		"'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB18030'",
		"'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'",
		"'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'",
		"'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'",
		"'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'",
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'",
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'",
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'",
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'",
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'",
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'",
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'",
		"'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'",
		"'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'",
		"'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'",
		"'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'",
		"'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'",
		"'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'",
		"'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'",
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'",
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'",
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'",
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'",
		"'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'",
		"'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'",
		"'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'",
		"'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'",
		"'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'",
		"'GEOMFROMTEXT'", "'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'",
		"'GREATEST'", "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'",
		"'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'",
		"'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'",
		"'ISSIMPLE'", "'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'",
		"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'",
		"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'",
		"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'",
		"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'",
		"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'",
		"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'",
		"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'",
		"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'",
		"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'",
		"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'",
		"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'",
		"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
		"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'",
		"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'",
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'",
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'",
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'",
		"'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'",
		"'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'",
		"'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'",
		"'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'",
		"'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'",
		"'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'",
		"'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'",
		"'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'",
		"'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'",
		"'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'",
		"'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'",
		"'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'",
		"'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'",
		"'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'",
		"'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'", "'UNCOMPRESSED_LENGTH'",
		"'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", "'UPPER'", "'UUID'", "'UUID_SHORT'",
		"'VALIDATE_PASSWORD_STRENGTH'", "'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'",
		"'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'",
		"'Y'", "'X'", "':='", "'+='", "'-='", "'*='", "'/='", "'%='", "'&='",
		"'^='", "'|='", "'*'", "'/'", "'%'", "'+'", "'-'", "'DIV'", "'MOD'",
		"'='", "'>'", "'<'", "'!'", "'~'", "'|'", "'&'", "'^'", "'.'", "'('",
		"')'", "','", "';'", "'@'", "'0'", "'1'", "'2'", "'''", "'\"'", "'`'",
		"':'",
	}
	staticData.symbolicNames = []string{
		"", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT",
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC",
		"ATTRIBUTE", "BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", "CALL", "CASCADE",
		"CASE", "CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE", "COLUMN",
		"CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS",
		"CURRENT", "CURRENT_ROLE", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES",
		"DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC",
		"DIAGNOSTICS", "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF",
		"EMPTY", "ENCLOSED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN",
		"FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED",
		"GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM", "IF",
		"IGNORE", "IGNORED", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT",
		"INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL",
		"LATERAL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES",
		"LOAD", "LOCK", "LOCKED", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT",
		"MATCH", "MAXVALUE", "MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG",
		"NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY",
		"OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY",
		"PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP",
		"RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT",
		"RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS",
		"SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_", "SPATIAL",
		"SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS",
		"SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING", "STATEMENT", "STRAIGHT_JOIN",
		"TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE",
		"UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE",
		"USE", "USING", "VALUES", "WHEN", "WHERE", "WHILE", "WITH", "WRITE",
		"XOR", "ZEROFILL", "TINYINT", "SMALLINT", "MEDIUMINT", "MIDDLEINT",
		"INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "BIGINT",
		"REAL", "DOUBLE", "PRECISION", "FLOAT", "FLOAT4", "FLOAT8", "DECIMAL",
		"DEC", "NUMERIC", "DATE", "TIME", "TIMESTAMP", "DATETIME", "YEAR", "CHAR",
		"VARCHAR", "NVARCHAR", "NATIONAL", "BINARY", "VARBINARY", "TINYBLOB",
		"BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB", "TINYTEXT", "TEXT", "MEDIUMTEXT",
		"LONGTEXT", "ENUM", "VARYING", "SERIAL", "YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE",
		"DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND", "MINUTE_SECOND", "SECOND_MICROSECOND",
		"MINUTE_MICROSECOND", "HOUR_MICROSECOND", "DAY_MICROSECOND", "JSON_ARRAY",
		"JSON_ARRAYAGG", "JSON_ARRAY_APPEND", "JSON_ARRAY_INSERT", "JSON_CONTAINS",
		"JSON_CONTAINS_PATH", "JSON_DEPTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS",
		"JSON_LENGTH", "JSON_MERGE", "JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE",
		"JSON_OBJECT", "JSON_OBJECTAGG", "JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE",
		"JSON_REMOVE", "JSON_REPLACE", "JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT",
		"JSON_SEARCH", "JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE",
		"JSON_TABLE", "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE",
		"NESTED", "ORDINALITY", "PATH", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR",
		"COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "GROUP_CONCAT", "LAG",
		"LAST_VALUE", "LEAD", "MAX", "MIN", "NTILE", "NTH_VALUE", "PERCENT_RANK",
		"RANK", "ROW_NUMBER", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP",
		"SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "CURRENT_DATE", "CURRENT_TIME",
		"CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE", "CURTIME", "DATE_ADD",
		"DATE_SUB", "EXTRACT", "LOCALTIMESTAMP", "NOW", "POSITION", "SUBSTR",
		"SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP",
		"ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM", "ANY", "AT",
		"AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT", "AVG_ROW_LENGTH",
		"BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN", "BTREE", "CACHE",
		"CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM", "PAGE_CHECKSUM",
		"CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "CLUSTERING", "COALESCE",
		"CODE", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT", "COMMIT",
		"COMPACT", "COMPLETION", "COMPRESSED", "COMPRESSION", "CONCURRENT",
		"CONNECT", "CONNECTION", "CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA",
		"CONSTRAINT_NAME", "CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", "CPU",
		"CYCLE", "CURSOR_NAME", "DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH",
		"DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", "DISABLE",
		"DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", "DYNAMIC", "ENABLE",
		"ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID", "END", "ENDS", "ENGINE",
		"ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", "EVENT", "EVENTS", "EVERY",
		"EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE",
		"FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS", "FIELDS", "FILE_BLOCK_SIZE",
		"FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING", "FOLLOWS", "FOUND",
		"FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS", "GROUP_REPLICATION",
		"HANDLER", "HASH", "HELP", "HISTORY", "HOST", "HOSTS", "IDENTIFIED",
		"IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES", "INITIAL_SIZE",
		"INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT", "INVISIBLE",
		"INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "JSON",
		"KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", "LIST",
		"LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY",
		"MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE",
		"MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT",
		"MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT",
		"MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY",
		"MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR",
		"MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS",
		"MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", "MID", "MIGRATE", "MIN_ROWS",
		"MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", "NAME", "NAMES",
		"NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY", "NOCYCLE", "NOMAXVALUE",
		"NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE", "ODBC", "OFFLINE", "OFFSET",
		"OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN", "OPTIMIZER_COSTS",
		"OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL",
		"PARSER", "PARTIAL", "PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME",
		"PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PRECEDING",
		"PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES",
		"PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER", "RECURSIVE", "REDO_BUFFER_SIZE",
		"REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG",
		"REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE",
		"REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB",
		"REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION",
		"RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING", "RETURNS",
		"REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT",
		"RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER",
		"SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT",
		"SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS",
		"SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE",
		"SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT",
		"STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING",
		"SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND",
		"SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY",
		"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL",
		"TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE",
		"UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES",
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT",
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML",
		"YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY",
		"HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "ADMIN", "APPLICATION_PASSWORD_ADMIN",
		"AUDIT_ADMIN", "BACKUP_ADMIN", "BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN",
		"CLONE_ADMIN", "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", "EXECUTE",
		"FILE", "FIREWALL_ADMIN", "FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS",
		"FLUSH_STATUS", "FLUSH_TABLES", "FLUSH_USER_RESOURCES", "GROUP_REPLICATION_ADMIN",
		"INNODB_REDO_LOG_ARCHIVE", "INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA",
		"NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN", "PERSIST_RO_VARIABLES_ADMIN",
		"PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER", "REPLICATION_SLAVE_ADMIN",
		"RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER", "ROLE_ADMIN", "ROUTINE",
		"S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN", "SET_USER_ID",
		"SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN", "TABLES",
		"TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN",
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257",
		"CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030",
		"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
		"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN",
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32",
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED",
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE",
		"GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING",
		"MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE",
		"ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN",
		"ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE",
		"ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN",
		"ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME",
		"CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH",
		"COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID",
		"CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY",
		"CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST",
		"CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK",
		"DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION",
		"DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE",
		"ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE",
		"FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64",
		"FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD",
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS",
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES",
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB",
		"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF",
		"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH",
		"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT",
		"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT",
		"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES",
		"RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME",
		"SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER", "SHA", "SHA1", "SHA2",
		"SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS",
		"SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY",
		"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS",
		"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE",
		"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT",
		"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT",
		"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB",
		"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB",
		"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED",
		"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT",
		"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS",
		"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB",
		"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT",
		"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE",
		"ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX",
		"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF",
		"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS",
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP",
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH",
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR",
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN",
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE",
		"PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL",
		"EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP",
		"DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", "ZERO_DECIMAL",
		"ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB",
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING",
		"FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL",
		"DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL",
		"BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID",
		"STRING_USER_NAME", "IP_ADDRESS", "LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION",
	}
	staticData.ruleNames = []string{
		"root", "sqlStatements", "sqlStatement", "emptyStatement_", "dmlStatement",
		"selectStatement", "lockClause", "tableSources", "tableSource", "querySpecification",
		"selectSpec", "selectElements", "selectElement", "fromClause", "limitClause",
		"limitClauseAtom", "fullId", "tableName", "fullColumnName", "collationName",
		"uid", "simpleId", "dottedId", "decimalLiteral", "stringLiteral", "booleanLiteral",
		"hexadecimalLiteral", "constant", "expressions", "functionCall", "aggregateWindowedFunction",
		"expression", "predicate", "expressionAtom", "unaryOperator", "comparisonOperator",
		"logicalOperator",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 1155, 396, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 1, 0, 3, 0, 76, 8, 0, 1, 0, 1, 0, 3, 0, 80, 8, 0, 1, 0, 1, 0, 1, 1,
		1, 1, 1, 1, 3, 1, 87, 8, 1, 1, 1, 3, 1, 90, 8, 1, 1, 1, 5, 1, 93, 8, 1,
		10, 1, 12, 1, 96, 9, 1, 1, 1, 1, 1, 1, 1, 3, 1, 101, 8, 1, 1, 1, 3, 1,
		104, 8, 1, 1, 1, 3, 1, 107, 8, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1,
		5, 1, 5, 3, 5, 117, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 125,
		8, 6, 1, 7, 1, 7, 1, 7, 5, 7, 130, 8, 7, 10, 7, 12, 7, 133, 9, 7, 1, 8,
		1, 8, 1, 9, 1, 9, 5, 9, 139, 8, 9, 10, 9, 12, 9, 142, 9, 9, 1, 9, 1, 9,
		3, 9, 146, 8, 9, 1, 9, 3, 9, 149, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 3, 10, 159, 8, 10, 1, 11, 1, 11, 3, 11, 163, 8,
		11, 1, 11, 1, 11, 5, 11, 167, 8, 11, 10, 11, 12, 11, 170, 9, 11, 1, 12,
		1, 12, 3, 12, 174, 8, 12, 1, 12, 3, 12, 177, 8, 12, 1, 12, 1, 12, 3, 12,
		181, 8, 12, 1, 12, 3, 12, 184, 8, 12, 3, 12, 186, 8, 12, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 3, 13, 193, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 199, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 206, 8, 14, 1,
		15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 214, 8, 16, 1, 17, 1, 17,
		1, 18, 1, 18, 1, 18, 3, 18, 221, 8, 18, 3, 18, 223, 8, 18, 1, 18, 3, 18,
		226, 8, 18, 1, 18, 1, 18, 3, 18, 230, 8, 18, 3, 18, 232, 8, 18, 1, 19,
		1, 19, 3, 19, 236, 8, 19, 1, 20, 1, 20, 1, 20, 3, 20, 241, 8, 20, 1, 21,
		1, 21, 1, 22, 1, 22, 1, 22, 3, 22, 248, 8, 22, 1, 23, 1, 23, 1, 24, 3,
		24, 253, 8, 24, 1, 24, 1, 24, 3, 24, 257, 8, 24, 1, 24, 4, 24, 260, 8,
		24, 11, 24, 12, 24, 261, 1, 24, 3, 24, 265, 8, 24, 1, 24, 1, 24, 3, 24,
		269, 8, 24, 1, 24, 1, 24, 3, 24, 273, 8, 24, 3, 24, 275, 8, 24, 1, 25,
		1, 25, 1, 26, 3, 26, 280, 8, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 27, 1, 27, 1, 27, 3, 27, 291, 8, 27, 1, 28, 1, 28, 1, 28, 5, 28,
		296, 8, 28, 10, 28, 12, 28, 299, 9, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 314,
		8, 31, 1, 31, 1, 31, 1, 31, 3, 31, 319, 8, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 5, 31, 325, 8, 31, 10, 31, 12, 31, 328, 9, 31, 1, 32, 1, 32, 1, 32,
		3, 32, 333, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1,
		32, 3, 32, 343, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 350, 8,
		32, 10, 32, 12, 32, 353, 9, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 5, 33, 364, 8, 33, 10, 33, 12, 33, 367, 9, 33, 1,
		33, 1, 33, 3, 33, 371, 8, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 386, 8, 35, 1,
		36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 394, 8, 36, 1, 36, 0, 2,
		62, 64, 37, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
		68, 70, 72, 0, 7, 2, 0, 6, 6, 49, 50, 1, 0, 624, 625, 3, 0, 1131, 1133,
		1142, 1142, 1144, 1144, 2, 0, 62, 62, 176, 176, 2, 0, 113, 113, 1120, 1120,
		3, 0, 62, 62, 176, 176, 660, 660, 3, 0, 113, 113, 1113, 1114, 1120, 1121,
		436, 0, 75, 1, 0, 0, 0, 2, 94, 1, 0, 0, 0, 4, 108, 1, 0, 0, 0, 6, 110,
		1, 0, 0, 0, 8, 112, 1, 0, 0, 0, 10, 114, 1, 0, 0, 0, 12, 124, 1, 0, 0,
		0, 14, 126, 1, 0, 0, 0, 16, 134, 1, 0, 0, 0, 18, 136, 1, 0, 0, 0, 20, 158,
		1, 0, 0, 0, 22, 162, 1, 0, 0, 0, 24, 185, 1, 0, 0, 0, 26, 187, 1, 0, 0,
		0, 28, 194, 1, 0, 0, 0, 30, 207, 1, 0, 0, 0, 32, 209, 1, 0, 0, 0, 34, 215,
		1, 0, 0, 0, 36, 231, 1, 0, 0, 0, 38, 235, 1, 0, 0, 0, 40, 240, 1, 0, 0,
		0, 42, 242, 1, 0, 0, 0, 44, 247, 1, 0, 0, 0, 46, 249, 1, 0, 0, 0, 48, 274,
		1, 0, 0, 0, 50, 276, 1, 0, 0, 0, 52, 279, 1, 0, 0, 0, 54, 290, 1, 0, 0,
		0, 56, 292, 1, 0, 0, 0, 58, 300, 1, 0, 0, 0, 60, 302, 1, 0, 0, 0, 62, 318,
		1, 0, 0, 0, 64, 329, 1, 0, 0, 0, 66, 370, 1, 0, 0, 0, 68, 372, 1, 0, 0,
		0, 70, 385, 1, 0, 0, 0, 72, 393, 1, 0, 0, 0, 74, 76, 3, 2, 1, 0, 75, 74,
		1, 0, 0, 0, 75, 76, 1, 0, 0, 0, 76, 79, 1, 0, 0, 0, 77, 78, 5, 1114, 0,
		0, 78, 80, 5, 1114, 0, 0, 79, 77, 1, 0, 0, 0, 79, 80, 1, 0, 0, 0, 80, 81,
		1, 0, 0, 0, 81, 82, 5, 0, 0, 1, 82, 1, 1, 0, 0, 0, 83, 86, 3, 4, 2, 0,
		84, 85, 5, 1114, 0, 0, 85, 87, 5, 1114, 0, 0, 86, 84, 1, 0, 0, 0, 86, 87,
		1, 0, 0, 0, 87, 89, 1, 0, 0, 0, 88, 90, 5, 1129, 0, 0, 89, 88, 1, 0, 0,
		0, 89, 90, 1, 0, 0, 0, 90, 93, 1, 0, 0, 0, 91, 93, 3, 6, 3, 0, 92, 83,
		1, 0, 0, 0, 92, 91, 1, 0, 0, 0, 93, 96, 1, 0, 0, 0, 94, 92, 1, 0, 0, 0,
		94, 95, 1, 0, 0, 0, 95, 106, 1, 0, 0, 0, 96, 94, 1, 0, 0, 0, 97, 103, 3,
		4, 2, 0, 98, 99, 5, 1114, 0, 0, 99, 101, 5, 1114, 0, 0, 100, 98, 1, 0,
		0, 0, 100, 101, 1, 0, 0, 0, 101, 102, 1, 0, 0, 0, 102, 104, 5, 1129, 0,
		0, 103, 100, 1, 0, 0, 0, 103, 104, 1, 0, 0, 0, 104, 107, 1, 0, 0, 0, 105,
		107, 3, 6, 3, 0, 106, 97, 1, 0, 0, 0, 106, 105, 1, 0, 0, 0, 107, 3, 1,
		0, 0, 0, 108, 109, 3, 8, 4, 0, 109, 5, 1, 0, 0, 0, 110, 111, 5, 1129, 0,
		0, 111, 7, 1, 0, 0, 0, 112, 113, 3, 10, 5, 0, 113, 9, 1, 0, 0, 0, 114,
		116, 3, 18, 9, 0, 115, 117, 3, 12, 6, 0, 116, 115, 1, 0, 0, 0, 116, 117,
		1, 0, 0, 0, 117, 11, 1, 0, 0, 0, 118, 119, 5, 64, 0, 0, 119, 125, 5, 182,
		0, 0, 120, 121, 5, 102, 0, 0, 121, 122, 5, 79, 0, 0, 122, 123, 5, 608,
		0, 0, 123, 125, 5, 509, 0, 0, 124, 118, 1, 0, 0, 0, 124, 120, 1, 0, 0,
		0, 125, 13, 1, 0, 0, 0, 126, 131, 3, 16, 8, 0, 127, 128, 5, 1128, 0, 0,
		128, 130, 3, 16, 8, 0, 129, 127, 1, 0, 0, 0, 130, 133, 1, 0, 0, 0, 131,
		129, 1, 0, 0, 0, 131, 132, 1, 0, 0, 0, 132, 15, 1, 0, 0, 0, 133, 131, 1,
		0, 0, 0, 134, 135, 3, 34, 17, 0, 135, 17, 1, 0, 0, 0, 136, 140, 5, 151,
		0, 0, 137, 139, 3, 20, 10, 0, 138, 137, 1, 0, 0, 0, 139, 142, 1, 0, 0,
		0, 140, 138, 1, 0, 0, 0, 140, 141, 1, 0, 0, 0, 141, 143, 1, 0, 0, 0, 142,
		140, 1, 0, 0, 0, 143, 145, 3, 22, 11, 0, 144, 146, 3, 26, 13, 0, 145, 144,
		1, 0, 0, 0, 145, 146, 1, 0, 0, 0, 146, 148, 1, 0, 0, 0, 147, 149, 3, 28,
		14, 0, 148, 147, 1, 0, 0, 0, 148, 149, 1, 0, 0, 0, 149, 19, 1, 0, 0, 0,
		150, 159, 7, 0, 0, 0, 151, 159, 5, 74, 0, 0, 152, 159, 5, 169, 0, 0, 153,
		159, 5, 164, 0, 0, 154, 159, 5, 162, 0, 0, 155, 159, 5, 623, 0, 0, 156,
		159, 7, 1, 0, 0, 157, 159, 5, 163, 0, 0, 158, 150, 1, 0, 0, 0, 158, 151,
		1, 0, 0, 0, 158, 152, 1, 0, 0, 0, 158, 153, 1, 0, 0, 0, 158, 154, 1, 0,
		0, 0, 158, 155, 1, 0, 0, 0, 158, 156, 1, 0, 0, 0, 158, 157, 1, 0, 0, 0,
		159, 21, 1, 0, 0, 0, 160, 163, 5, 1110, 0, 0, 161, 163, 3, 24, 12, 0, 162,
		160, 1, 0, 0, 0, 162, 161, 1, 0, 0, 0, 163, 168, 1, 0, 0, 0, 164, 165,
		5, 1128, 0, 0, 165, 167, 3, 24, 12, 0, 166, 164, 1, 0, 0, 0, 167, 170,
		1, 0, 0, 0, 168, 166, 1, 0, 0, 0, 168, 169, 1, 0, 0, 0, 169, 23, 1, 0,
		0, 0, 170, 168, 1, 0, 0, 0, 171, 176, 3, 36, 18, 0, 172, 174, 5, 12, 0,
		0, 173, 172, 1, 0, 0, 0, 173, 174, 1, 0, 0, 0, 174, 175, 1, 0, 0, 0, 175,
		177, 3, 40, 20, 0, 176, 173, 1, 0, 0, 0, 176, 177, 1, 0, 0, 0, 177, 186,
		1, 0, 0, 0, 178, 183, 3, 58, 29, 0, 179, 181, 5, 12, 0, 0, 180, 179, 1,
		0, 0, 0, 180, 181, 1, 0, 0, 0, 181, 182, 1, 0, 0, 0, 182, 184, 3, 40, 20,
		0, 183, 180, 1, 0, 0, 0, 183, 184, 1, 0, 0, 0, 184, 186, 1, 0, 0, 0, 185,
		171, 1, 0, 0, 0, 185, 178, 1, 0, 0, 0, 186, 25, 1, 0, 0, 0, 187, 188, 5,
		67, 0, 0, 188, 189, 3, 14, 7, 0, 189, 192, 1, 0, 0, 0, 190, 191, 5, 188,
		0, 0, 191, 193, 3, 62, 31, 0, 192, 190, 1, 0, 0, 0, 192, 193, 1, 0, 0,
		0, 193, 27, 1, 0, 0, 0, 194, 205, 5, 98, 0, 0, 195, 196, 3, 30, 15, 0,
		196, 197, 5, 1128, 0, 0, 197, 199, 1, 0, 0, 0, 198, 195, 1, 0, 0, 0, 198,
		199, 1, 0, 0, 0, 199, 200, 1, 0, 0, 0, 200, 206, 3, 30, 15, 0, 201, 202,
		3, 30, 15, 0, 202, 203, 5, 530, 0, 0, 203, 204, 3, 30, 15, 0, 204, 206,
		1, 0, 0, 0, 205, 198, 1, 0, 0, 0, 205, 201, 1, 0, 0, 0, 206, 29, 1, 0,
		0, 0, 207, 208, 3, 46, 23, 0, 208, 31, 1, 0, 0, 0, 209, 213, 3, 40, 20,
		0, 210, 214, 5, 1148, 0, 0, 211, 212, 5, 1125, 0, 0, 212, 214, 3, 40, 20,
		0, 213, 210, 1, 0, 0, 0, 213, 211, 1, 0, 0, 0, 213, 214, 1, 0, 0, 0, 214,
		33, 1, 0, 0, 0, 215, 216, 3, 32, 16, 0, 216, 35, 1, 0, 0, 0, 217, 222,
		3, 40, 20, 0, 218, 220, 3, 44, 22, 0, 219, 221, 3, 44, 22, 0, 220, 219,
		1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 223, 1, 0, 0, 0, 222, 218, 1, 0,
		0, 0, 222, 223, 1, 0, 0, 0, 223, 232, 1, 0, 0, 0, 224, 226, 9, 0, 0, 0,
		225, 224, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 227, 1, 0, 0, 0, 227,
		229, 3, 44, 22, 0, 228, 230, 3, 44, 22, 0, 229, 228, 1, 0, 0, 0, 229, 230,
		1, 0, 0, 0, 230, 232, 1, 0, 0, 0, 231, 217, 1, 0, 0, 0, 231, 225, 1, 0,
		0, 0, 232, 37, 1, 0, 0, 0, 233, 236, 3, 40, 20, 0, 234, 236, 5, 1141, 0,
		0, 235, 233, 1, 0, 0, 0, 235, 234, 1, 0, 0, 0, 236, 39, 1, 0, 0, 0, 237,
		241, 3, 42, 21, 0, 238, 241, 5, 1150, 0, 0, 239, 241, 5, 1138, 0, 0, 240,
		237, 1, 0, 0, 0, 240, 238, 1, 0, 0, 0, 240, 239, 1, 0, 0, 0, 241, 41, 1,
		0, 0, 0, 242, 243, 5, 1149, 0, 0, 243, 43, 1, 0, 0, 0, 244, 248, 5, 1148,
		0, 0, 245, 246, 5, 1125, 0, 0, 246, 248, 3, 40, 20, 0, 247, 244, 1, 0,
		0, 0, 247, 245, 1, 0, 0, 0, 248, 45, 1, 0, 0, 0, 249, 250, 7, 2, 0, 0,
		250, 47, 1, 0, 0, 0, 251, 253, 5, 1147, 0, 0, 252, 251, 1, 0, 0, 0, 252,
		253, 1, 0, 0, 0, 253, 254, 1, 0, 0, 0, 254, 257, 5, 1141, 0, 0, 255, 257,
		5, 1140, 0, 0, 256, 252, 1, 0, 0, 0, 256, 255, 1, 0, 0, 0, 257, 259, 1,
		0, 0, 0, 258, 260, 5, 1141, 0, 0, 259, 258, 1, 0, 0, 0, 260, 261, 1, 0,
		0, 0, 261, 259, 1, 0, 0, 0, 261, 262, 1, 0, 0, 0, 262, 275, 1, 0, 0, 0,
		263, 265, 5, 1147, 0, 0, 264, 263, 1, 0, 0, 0, 264, 265, 1, 0, 0, 0, 265,
		266, 1, 0, 0, 0, 266, 269, 5, 1141, 0, 0, 267, 269, 5, 1140, 0, 0, 268,
		264, 1, 0, 0, 0, 268, 267, 1, 0, 0, 0, 269, 272, 1, 0, 0, 0, 270, 271,
		5, 27, 0, 0, 271, 273, 3, 38, 19, 0, 272, 270, 1, 0, 0, 0, 272, 273, 1,
		0, 0, 0, 273, 275, 1, 0, 0, 0, 274, 256, 1, 0, 0, 0, 274, 268, 1, 0, 0,
		0, 275, 49, 1, 0, 0, 0, 276, 277, 7, 3, 0, 0, 277, 51, 1, 0, 0, 0, 278,
		280, 5, 1147, 0, 0, 279, 278, 1, 0, 0, 0, 279, 280, 1, 0, 0, 0, 280, 281,
		1, 0, 0, 0, 281, 282, 5, 1143, 0, 0, 282, 53, 1, 0, 0, 0, 283, 291, 3,
		48, 24, 0, 284, 291, 3, 46, 23, 0, 285, 286, 5, 1114, 0, 0, 286, 291, 3,
		46, 23, 0, 287, 291, 3, 52, 26, 0, 288, 291, 3, 50, 25, 0, 289, 291, 5,
		1144, 0, 0, 290, 283, 1, 0, 0, 0, 290, 284, 1, 0, 0, 0, 290, 285, 1, 0,
		0, 0, 290, 287, 1, 0, 0, 0, 290, 288, 1, 0, 0, 0, 290, 289, 1, 0, 0, 0,
		291, 55, 1, 0, 0, 0, 292, 297, 3, 62, 31, 0, 293, 294, 5, 1128, 0, 0, 294,
		296, 3, 62, 31, 0, 295, 293, 1, 0, 0, 0, 296, 299, 1, 0, 0, 0, 297, 295,
		1, 0, 0, 0, 297, 298, 1, 0, 0, 0, 298, 57, 1, 0, 0, 0, 299, 297, 1, 0,
		0, 0, 300, 301, 3, 60, 30, 0, 301, 59, 1, 0, 0, 0, 302, 303, 5, 288, 0,
		0, 303, 304, 5, 1126, 0, 0, 304, 305, 5, 1110, 0, 0, 305, 306, 5, 1127,
		0, 0, 306, 61, 1, 0, 0, 0, 307, 308, 6, 31, -1, 0, 308, 309, 7, 4, 0, 0,
		309, 319, 3, 62, 31, 4, 310, 311, 3, 64, 32, 0, 311, 313, 5, 87, 0, 0,
		312, 314, 5, 113, 0, 0, 313, 312, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314,
		315, 1, 0, 0, 0, 315, 316, 7, 5, 0, 0, 316, 319, 1, 0, 0, 0, 317, 319,
		3, 64, 32, 0, 318, 307, 1, 0, 0, 0, 318, 310, 1, 0, 0, 0, 318, 317, 1,
		0, 0, 0, 319, 326, 1, 0, 0, 0, 320, 321, 10, 3, 0, 0, 321, 322, 3, 72,
		36, 0, 322, 323, 3, 62, 31, 4, 323, 325, 1, 0, 0, 0, 324, 320, 1, 0, 0,
		0, 325, 328, 1, 0, 0, 0, 326, 324, 1, 0, 0, 0, 326, 327, 1, 0, 0, 0, 327,
		63, 1, 0, 0, 0, 328, 326, 1, 0, 0, 0, 329, 332, 6, 32, -1, 0, 330, 331,
		5, 1153, 0, 0, 331, 333, 5, 1101, 0, 0, 332, 330, 1, 0, 0, 0, 332, 333,
		1, 0, 0, 0, 333, 334, 1, 0, 0, 0, 334, 335, 3, 66, 33, 0, 335, 351, 1,
		0, 0, 0, 336, 337, 10, 2, 0, 0, 337, 338, 3, 70, 35, 0, 338, 339, 3, 64,
		32, 3, 339, 350, 1, 0, 0, 0, 340, 342, 10, 3, 0, 0, 341, 343, 5, 113, 0,
		0, 342, 341, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344,
		345, 5, 79, 0, 0, 345, 346, 5, 1126, 0, 0, 346, 347, 3, 56, 28, 0, 347,
		348, 5, 1127, 0, 0, 348, 350, 1, 0, 0, 0, 349, 336, 1, 0, 0, 0, 349, 340,
		1, 0, 0, 0, 350, 353, 1, 0, 0, 0, 351, 349, 1, 0, 0, 0, 351, 352, 1, 0,
		0, 0, 352, 65, 1, 0, 0, 0, 353, 351, 1, 0, 0, 0, 354, 371, 3, 54, 27, 0,
		355, 371, 3, 36, 18, 0, 356, 357, 3, 68, 34, 0, 357, 358, 3, 66, 33, 0,
		358, 371, 1, 0, 0, 0, 359, 360, 5, 1126, 0, 0, 360, 365, 3, 62, 31, 0,
		361, 362, 5, 1128, 0, 0, 362, 364, 3, 62, 31, 0, 363, 361, 1, 0, 0, 0,
		364, 367, 1, 0, 0, 0, 365, 363, 1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366,
		368, 1, 0, 0, 0, 367, 365, 1, 0, 0, 0, 368, 369, 5, 1127, 0, 0, 369, 371,
		1, 0, 0, 0, 370, 354, 1, 0, 0, 0, 370, 355, 1, 0, 0, 0, 370, 356, 1, 0,
		0, 0, 370, 359, 1, 0, 0, 0, 371, 67, 1, 0, 0, 0, 372, 373, 7, 6, 0, 0,
		373, 69, 1, 0, 0, 0, 374, 386, 5, 1117, 0, 0, 375, 386, 5, 1118, 0, 0,
		376, 386, 5, 1119, 0, 0, 377, 378, 5, 1119, 0, 0, 378, 386, 5, 1117, 0,
		0, 379, 380, 5, 1118, 0, 0, 380, 386, 5, 1117, 0, 0, 381, 382, 5, 1119,
		0, 0, 382, 386, 5, 1118, 0, 0, 383, 384, 5, 1120, 0, 0, 384, 386, 5, 1117,
		0, 0, 385, 374, 1, 0, 0, 0, 385, 375, 1, 0, 0, 0, 385, 376, 1, 0, 0, 0,
		385, 377, 1, 0, 0, 0, 385, 379, 1, 0, 0, 0, 385, 381, 1, 0, 0, 0, 385,
		383, 1, 0, 0, 0, 386, 71, 1, 0, 0, 0, 387, 394, 5, 10, 0, 0, 388, 389,
		5, 1123, 0, 0, 389, 394, 5, 1123, 0, 0, 390, 394, 5, 122, 0, 0, 391, 392,
		5, 1122, 0, 0, 392, 394, 5, 1122, 0, 0, 393, 387, 1, 0, 0, 0, 393, 388,
		1, 0, 0, 0, 393, 390, 1, 0, 0, 0, 393, 391, 1, 0, 0, 0, 394, 73, 1, 0,
		0, 0, 56, 75, 79, 86, 89, 92, 94, 100, 103, 106, 116, 124, 131, 140, 145,
		148, 158, 162, 168, 173, 176, 180, 183, 185, 192, 198, 205, 213, 220, 222,
		225, 229, 231, 235, 240, 247, 252, 256, 261, 264, 268, 272, 274, 279, 290,
		297, 313, 318, 326, 332, 342, 349, 351, 365, 370, 385, 393,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MySqlParserInit initializes any static state used to implement MySqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMySqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MySqlParserInit() {
	staticData := &mysqlparserParserStaticData
	staticData.once.Do(mysqlparserParserInit)
}

// NewMySqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMySqlParser(input antlr.TokenStream) *MySqlParser {
	MySqlParserInit()
	this := new(MySqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &mysqlparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// MySqlParser tokens.
const (
	MySqlParserEOF                               = antlr.TokenEOF
	MySqlParserSPACE                             = 1
	MySqlParserSPEC_MYSQL_COMMENT                = 2
	MySqlParserCOMMENT_INPUT                     = 3
	MySqlParserLINE_COMMENT                      = 4
	MySqlParserADD                               = 5
	MySqlParserALL                               = 6
	MySqlParserALTER                             = 7
	MySqlParserALWAYS                            = 8
	MySqlParserANALYZE                           = 9
	MySqlParserAND                               = 10
	MySqlParserARRAY                             = 11
	MySqlParserAS                                = 12
	MySqlParserASC                               = 13
	MySqlParserATTRIBUTE                         = 14
	MySqlParserBEFORE                            = 15
	MySqlParserBETWEEN                           = 16
	MySqlParserBOTH                              = 17
	MySqlParserBUCKETS                           = 18
	MySqlParserBY                                = 19
	MySqlParserCALL                              = 20
	MySqlParserCASCADE                           = 21
	MySqlParserCASE                              = 22
	MySqlParserCAST                              = 23
	MySqlParserCHANGE                            = 24
	MySqlParserCHARACTER                         = 25
	MySqlParserCHECK                             = 26
	MySqlParserCOLLATE                           = 27
	MySqlParserCOLUMN                            = 28
	MySqlParserCONDITION                         = 29
	MySqlParserCONSTRAINT                        = 30
	MySqlParserCONTINUE                          = 31
	MySqlParserCONVERT                           = 32
	MySqlParserCREATE                            = 33
	MySqlParserCROSS                             = 34
	MySqlParserCURRENT                           = 35
	MySqlParserCURRENT_ROLE                      = 36
	MySqlParserCURRENT_USER                      = 37
	MySqlParserCURSOR                            = 38
	MySqlParserDATABASE                          = 39
	MySqlParserDATABASES                         = 40
	MySqlParserDECLARE                           = 41
	MySqlParserDEFAULT                           = 42
	MySqlParserDELAYED                           = 43
	MySqlParserDELETE                            = 44
	MySqlParserDESC                              = 45
	MySqlParserDESCRIBE                          = 46
	MySqlParserDETERMINISTIC                     = 47
	MySqlParserDIAGNOSTICS                       = 48
	MySqlParserDISTINCT                          = 49
	MySqlParserDISTINCTROW                       = 50
	MySqlParserDROP                              = 51
	MySqlParserEACH                              = 52
	MySqlParserELSE                              = 53
	MySqlParserELSEIF                            = 54
	MySqlParserEMPTY                             = 55
	MySqlParserENCLOSED                          = 56
	MySqlParserESCAPED                           = 57
	MySqlParserEXCEPT                            = 58
	MySqlParserEXISTS                            = 59
	MySqlParserEXIT                              = 60
	MySqlParserEXPLAIN                           = 61
	MySqlParserFALSE                             = 62
	MySqlParserFETCH                             = 63
	MySqlParserFOR                               = 64
	MySqlParserFORCE                             = 65
	MySqlParserFOREIGN                           = 66
	MySqlParserFROM                              = 67
	MySqlParserFULLTEXT                          = 68
	MySqlParserGENERATED                         = 69
	MySqlParserGET                               = 70
	MySqlParserGRANT                             = 71
	MySqlParserGROUP                             = 72
	MySqlParserHAVING                            = 73
	MySqlParserHIGH_PRIORITY                     = 74
	MySqlParserHISTOGRAM                         = 75
	MySqlParserIF                                = 76
	MySqlParserIGNORE                            = 77
	MySqlParserIGNORED                           = 78
	MySqlParserIN                                = 79
	MySqlParserINDEX                             = 80
	MySqlParserINFILE                            = 81
	MySqlParserINNER                             = 82
	MySqlParserINOUT                             = 83
	MySqlParserINSERT                            = 84
	MySqlParserINTERVAL                          = 85
	MySqlParserINTO                              = 86
	MySqlParserIS                                = 87
	MySqlParserITERATE                           = 88
	MySqlParserJOIN                              = 89
	MySqlParserKEY                               = 90
	MySqlParserKEYS                              = 91
	MySqlParserKILL                              = 92
	MySqlParserLATERAL                           = 93
	MySqlParserLEADING                           = 94
	MySqlParserLEAVE                             = 95
	MySqlParserLEFT                              = 96
	MySqlParserLIKE                              = 97
	MySqlParserLIMIT                             = 98
	MySqlParserLINEAR                            = 99
	MySqlParserLINES                             = 100
	MySqlParserLOAD                              = 101
	MySqlParserLOCK                              = 102
	MySqlParserLOCKED                            = 103
	MySqlParserLOOP                              = 104
	MySqlParserLOW_PRIORITY                      = 105
	MySqlParserMASTER_BIND                       = 106
	MySqlParserMASTER_SSL_VERIFY_SERVER_CERT     = 107
	MySqlParserMATCH                             = 108
	MySqlParserMAXVALUE                          = 109
	MySqlParserMINVALUE                          = 110
	MySqlParserMODIFIES                          = 111
	MySqlParserNATURAL                           = 112
	MySqlParserNOT                               = 113
	MySqlParserNO_WRITE_TO_BINLOG                = 114
	MySqlParserNULL_LITERAL                      = 115
	MySqlParserNUMBER                            = 116
	MySqlParserON                                = 117
	MySqlParserOPTIMIZE                          = 118
	MySqlParserOPTION                            = 119
	MySqlParserOPTIONAL                          = 120
	MySqlParserOPTIONALLY                        = 121
	MySqlParserOR                                = 122
	MySqlParserORDER                             = 123
	MySqlParserOUT                               = 124
	MySqlParserOUTER                             = 125
	MySqlParserOUTFILE                           = 126
	MySqlParserOVER                              = 127
	MySqlParserPARTITION                         = 128
	MySqlParserPRIMARY                           = 129
	MySqlParserPROCEDURE                         = 130
	MySqlParserPURGE                             = 131
	MySqlParserRANGE                             = 132
	MySqlParserREAD                              = 133
	MySqlParserREADS                             = 134
	MySqlParserREFERENCES                        = 135
	MySqlParserREGEXP                            = 136
	MySqlParserRELEASE                           = 137
	MySqlParserRENAME                            = 138
	MySqlParserREPEAT                            = 139
	MySqlParserREPLACE                           = 140
	MySqlParserREQUIRE                           = 141
	MySqlParserRESIGNAL                          = 142
	MySqlParserRESTRICT                          = 143
	MySqlParserRETAIN                            = 144
	MySqlParserRETURN                            = 145
	MySqlParserREVOKE                            = 146
	MySqlParserRIGHT                             = 147
	MySqlParserRLIKE                             = 148
	MySqlParserSCHEMA                            = 149
	MySqlParserSCHEMAS                           = 150
	MySqlParserSELECT                            = 151
	MySqlParserSET                               = 152
	MySqlParserSEPARATOR                         = 153
	MySqlParserSHOW                              = 154
	MySqlParserSIGNAL                            = 155
	MySqlParserSKIP_                             = 156
	MySqlParserSPATIAL                           = 157
	MySqlParserSQL                               = 158
	MySqlParserSQLEXCEPTION                      = 159
	MySqlParserSQLSTATE                          = 160
	MySqlParserSQLWARNING                        = 161
	MySqlParserSQL_BIG_RESULT                    = 162
	MySqlParserSQL_CALC_FOUND_ROWS               = 163
	MySqlParserSQL_SMALL_RESULT                  = 164
	MySqlParserSSL                               = 165
	MySqlParserSTACKED                           = 166
	MySqlParserSTARTING                          = 167
	MySqlParserSTATEMENT                         = 168
	MySqlParserSTRAIGHT_JOIN                     = 169
	MySqlParserTABLE                             = 170
	MySqlParserTERMINATED                        = 171
	MySqlParserTHEN                              = 172
	MySqlParserTO                                = 173
	MySqlParserTRAILING                          = 174
	MySqlParserTRIGGER                           = 175
	MySqlParserTRUE                              = 176
	MySqlParserUNDO                              = 177
	MySqlParserUNION                             = 178
	MySqlParserUNIQUE                            = 179
	MySqlParserUNLOCK                            = 180
	MySqlParserUNSIGNED                          = 181
	MySqlParserUPDATE                            = 182
	MySqlParserUSAGE                             = 183
	MySqlParserUSE                               = 184
	MySqlParserUSING                             = 185
	MySqlParserVALUES                            = 186
	MySqlParserWHEN                              = 187
	MySqlParserWHERE                             = 188
	MySqlParserWHILE                             = 189
	MySqlParserWITH                              = 190
	MySqlParserWRITE                             = 191
	MySqlParserXOR                               = 192
	MySqlParserZEROFILL                          = 193
	MySqlParserTINYINT                           = 194
	MySqlParserSMALLINT                          = 195
	MySqlParserMEDIUMINT                         = 196
	MySqlParserMIDDLEINT                         = 197
	MySqlParserINT                               = 198
	MySqlParserINT1                              = 199
	MySqlParserINT2                              = 200
	MySqlParserINT3                              = 201
	MySqlParserINT4                              = 202
	MySqlParserINT8                              = 203
	MySqlParserINTEGER                           = 204
	MySqlParserBIGINT                            = 205
	MySqlParserREAL                              = 206
	MySqlParserDOUBLE                            = 207
	MySqlParserPRECISION                         = 208
	MySqlParserFLOAT                             = 209
	MySqlParserFLOAT4                            = 210
	MySqlParserFLOAT8                            = 211
	MySqlParserDECIMAL                           = 212
	MySqlParserDEC                               = 213
	MySqlParserNUMERIC                           = 214
	MySqlParserDATE                              = 215
	MySqlParserTIME                              = 216
	MySqlParserTIMESTAMP                         = 217
	MySqlParserDATETIME                          = 218
	MySqlParserYEAR                              = 219
	MySqlParserCHAR                              = 220
	MySqlParserVARCHAR                           = 221
	MySqlParserNVARCHAR                          = 222
	MySqlParserNATIONAL                          = 223
	MySqlParserBINARY                            = 224
	MySqlParserVARBINARY                         = 225
	MySqlParserTINYBLOB                          = 226
	MySqlParserBLOB                              = 227
	MySqlParserMEDIUMBLOB                        = 228
	MySqlParserLONG                              = 229
	MySqlParserLONGBLOB                          = 230
	MySqlParserTINYTEXT                          = 231
	MySqlParserTEXT                              = 232
	MySqlParserMEDIUMTEXT                        = 233
	MySqlParserLONGTEXT                          = 234
	MySqlParserENUM                              = 235
	MySqlParserVARYING                           = 236
	MySqlParserSERIAL                            = 237
	MySqlParserYEAR_MONTH                        = 238
	MySqlParserDAY_HOUR                          = 239
	MySqlParserDAY_MINUTE                        = 240
	MySqlParserDAY_SECOND                        = 241
	MySqlParserHOUR_MINUTE                       = 242
	MySqlParserHOUR_SECOND                       = 243
	MySqlParserMINUTE_SECOND                     = 244
	MySqlParserSECOND_MICROSECOND                = 245
	MySqlParserMINUTE_MICROSECOND                = 246
	MySqlParserHOUR_MICROSECOND                  = 247
	MySqlParserDAY_MICROSECOND                   = 248
	MySqlParserJSON_ARRAY                        = 249
	MySqlParserJSON_ARRAYAGG                     = 250
	MySqlParserJSON_ARRAY_APPEND                 = 251
	MySqlParserJSON_ARRAY_INSERT                 = 252
	MySqlParserJSON_CONTAINS                     = 253
	MySqlParserJSON_CONTAINS_PATH                = 254
	MySqlParserJSON_DEPTH                        = 255
	MySqlParserJSON_EXTRACT                      = 256
	MySqlParserJSON_INSERT                       = 257
	MySqlParserJSON_KEYS                         = 258
	MySqlParserJSON_LENGTH                       = 259
	MySqlParserJSON_MERGE                        = 260
	MySqlParserJSON_MERGE_PATCH                  = 261
	MySqlParserJSON_MERGE_PRESERVE               = 262
	MySqlParserJSON_OBJECT                       = 263
	MySqlParserJSON_OBJECTAGG                    = 264
	MySqlParserJSON_OVERLAPS                     = 265
	MySqlParserJSON_PRETTY                       = 266
	MySqlParserJSON_QUOTE                        = 267
	MySqlParserJSON_REMOVE                       = 268
	MySqlParserJSON_REPLACE                      = 269
	MySqlParserJSON_SCHEMA_VALID                 = 270
	MySqlParserJSON_SCHEMA_VALIDATION_REPORT     = 271
	MySqlParserJSON_SEARCH                       = 272
	MySqlParserJSON_SET                          = 273
	MySqlParserJSON_STORAGE_FREE                 = 274
	MySqlParserJSON_STORAGE_SIZE                 = 275
	MySqlParserJSON_TABLE                        = 276
	MySqlParserJSON_TYPE                         = 277
	MySqlParserJSON_UNQUOTE                      = 278
	MySqlParserJSON_VALID                        = 279
	MySqlParserJSON_VALUE                        = 280
	MySqlParserNESTED                            = 281
	MySqlParserORDINALITY                        = 282
	MySqlParserPATH                              = 283
	MySqlParserAVG                               = 284
	MySqlParserBIT_AND                           = 285
	MySqlParserBIT_OR                            = 286
	MySqlParserBIT_XOR                           = 287
	MySqlParserCOUNT                             = 288
	MySqlParserCUME_DIST                         = 289
	MySqlParserDENSE_RANK                        = 290
	MySqlParserFIRST_VALUE                       = 291
	MySqlParserGROUP_CONCAT                      = 292
	MySqlParserLAG                               = 293
	MySqlParserLAST_VALUE                        = 294
	MySqlParserLEAD                              = 295
	MySqlParserMAX                               = 296
	MySqlParserMIN                               = 297
	MySqlParserNTILE                             = 298
	MySqlParserNTH_VALUE                         = 299
	MySqlParserPERCENT_RANK                      = 300
	MySqlParserRANK                              = 301
	MySqlParserROW_NUMBER                        = 302
	MySqlParserSTD                               = 303
	MySqlParserSTDDEV                            = 304
	MySqlParserSTDDEV_POP                        = 305
	MySqlParserSTDDEV_SAMP                       = 306
	MySqlParserSUM                               = 307
	MySqlParserVAR_POP                           = 308
	MySqlParserVAR_SAMP                          = 309
	MySqlParserVARIANCE                          = 310
	MySqlParserCURRENT_DATE                      = 311
	MySqlParserCURRENT_TIME                      = 312
	MySqlParserCURRENT_TIMESTAMP                 = 313
	MySqlParserLOCALTIME                         = 314
	MySqlParserCURDATE                           = 315
	MySqlParserCURTIME                           = 316
	MySqlParserDATE_ADD                          = 317
	MySqlParserDATE_SUB                          = 318
	MySqlParserEXTRACT                           = 319
	MySqlParserLOCALTIMESTAMP                    = 320
	MySqlParserNOW                               = 321
	MySqlParserPOSITION                          = 322
	MySqlParserSUBSTR                            = 323
	MySqlParserSUBSTRING                         = 324
	MySqlParserSYSDATE                           = 325
	MySqlParserTRIM                              = 326
	MySqlParserUTC_DATE                          = 327
	MySqlParserUTC_TIME                          = 328
	MySqlParserUTC_TIMESTAMP                     = 329
	MySqlParserACCOUNT                           = 330
	MySqlParserACTION                            = 331
	MySqlParserAFTER                             = 332
	MySqlParserAGGREGATE                         = 333
	MySqlParserALGORITHM                         = 334
	MySqlParserANY                               = 335
	MySqlParserAT                                = 336
	MySqlParserAUTHORS                           = 337
	MySqlParserAUTOCOMMIT                        = 338
	MySqlParserAUTOEXTEND_SIZE                   = 339
	MySqlParserAUTO_INCREMENT                    = 340
	MySqlParserAVG_ROW_LENGTH                    = 341
	MySqlParserBEGIN                             = 342
	MySqlParserBINLOG                            = 343
	MySqlParserBIT                               = 344
	MySqlParserBLOCK                             = 345
	MySqlParserBOOL                              = 346
	MySqlParserBOOLEAN                           = 347
	MySqlParserBTREE                             = 348
	MySqlParserCACHE                             = 349
	MySqlParserCASCADED                          = 350
	MySqlParserCHAIN                             = 351
	MySqlParserCHANGED                           = 352
	MySqlParserCHANNEL                           = 353
	MySqlParserCHECKSUM                          = 354
	MySqlParserPAGE_CHECKSUM                     = 355
	MySqlParserCIPHER                            = 356
	MySqlParserCLASS_ORIGIN                      = 357
	MySqlParserCLIENT                            = 358
	MySqlParserCLOSE                             = 359
	MySqlParserCLUSTERING                        = 360
	MySqlParserCOALESCE                          = 361
	MySqlParserCODE                              = 362
	MySqlParserCOLUMNS                           = 363
	MySqlParserCOLUMN_FORMAT                     = 364
	MySqlParserCOLUMN_NAME                       = 365
	MySqlParserCOMMENT                           = 366
	MySqlParserCOMMIT                            = 367
	MySqlParserCOMPACT                           = 368
	MySqlParserCOMPLETION                        = 369
	MySqlParserCOMPRESSED                        = 370
	MySqlParserCOMPRESSION                       = 371
	MySqlParserCONCURRENT                        = 372
	MySqlParserCONNECT                           = 373
	MySqlParserCONNECTION                        = 374
	MySqlParserCONSISTENT                        = 375
	MySqlParserCONSTRAINT_CATALOG                = 376
	MySqlParserCONSTRAINT_SCHEMA                 = 377
	MySqlParserCONSTRAINT_NAME                   = 378
	MySqlParserCONTAINS                          = 379
	MySqlParserCONTEXT                           = 380
	MySqlParserCONTRIBUTORS                      = 381
	MySqlParserCOPY                              = 382
	MySqlParserCPU                               = 383
	MySqlParserCYCLE                             = 384
	MySqlParserCURSOR_NAME                       = 385
	MySqlParserDATA                              = 386
	MySqlParserDATAFILE                          = 387
	MySqlParserDEALLOCATE                        = 388
	MySqlParserDEFAULT_AUTH                      = 389
	MySqlParserDEFINER                           = 390
	MySqlParserDELAY_KEY_WRITE                   = 391
	MySqlParserDES_KEY_FILE                      = 392
	MySqlParserDIRECTORY                         = 393
	MySqlParserDISABLE                           = 394
	MySqlParserDISCARD                           = 395
	MySqlParserDISK                              = 396
	MySqlParserDO                                = 397
	MySqlParserDUMPFILE                          = 398
	MySqlParserDUPLICATE                         = 399
	MySqlParserDYNAMIC                           = 400
	MySqlParserENABLE                            = 401
	MySqlParserENCRYPTED                         = 402
	MySqlParserENCRYPTION                        = 403
	MySqlParserENCRYPTION_KEY_ID                 = 404
	MySqlParserEND                               = 405
	MySqlParserENDS                              = 406
	MySqlParserENGINE                            = 407
	MySqlParserENGINES                           = 408
	MySqlParserERROR                             = 409
	MySqlParserERRORS                            = 410
	MySqlParserESCAPE                            = 411
	MySqlParserEVEN                              = 412
	MySqlParserEVENT                             = 413
	MySqlParserEVENTS                            = 414
	MySqlParserEVERY                             = 415
	MySqlParserEXCHANGE                          = 416
	MySqlParserEXCLUSIVE                         = 417
	MySqlParserEXPIRE                            = 418
	MySqlParserEXPORT                            = 419
	MySqlParserEXTENDED                          = 420
	MySqlParserEXTENT_SIZE                       = 421
	MySqlParserFAILED_LOGIN_ATTEMPTS             = 422
	MySqlParserFAST                              = 423
	MySqlParserFAULTS                            = 424
	MySqlParserFIELDS                            = 425
	MySqlParserFILE_BLOCK_SIZE                   = 426
	MySqlParserFILTER                            = 427
	MySqlParserFIRST                             = 428
	MySqlParserFIXED                             = 429
	MySqlParserFLUSH                             = 430
	MySqlParserFOLLOWING                         = 431
	MySqlParserFOLLOWS                           = 432
	MySqlParserFOUND                             = 433
	MySqlParserFULL                              = 434
	MySqlParserFUNCTION                          = 435
	MySqlParserGENERAL                           = 436
	MySqlParserGLOBAL                            = 437
	MySqlParserGRANTS                            = 438
	MySqlParserGROUP_REPLICATION                 = 439
	MySqlParserHANDLER                           = 440
	MySqlParserHASH                              = 441
	MySqlParserHELP                              = 442
	MySqlParserHISTORY                           = 443
	MySqlParserHOST                              = 444
	MySqlParserHOSTS                             = 445
	MySqlParserIDENTIFIED                        = 446
	MySqlParserIGNORE_SERVER_IDS                 = 447
	MySqlParserIMPORT                            = 448
	MySqlParserINCREMENT                         = 449
	MySqlParserINDEXES                           = 450
	MySqlParserINITIAL_SIZE                      = 451
	MySqlParserINPLACE                           = 452
	MySqlParserINSERT_METHOD                     = 453
	MySqlParserINSTALL                           = 454
	MySqlParserINSTANCE                          = 455
	MySqlParserINSTANT                           = 456
	MySqlParserINVISIBLE                         = 457
	MySqlParserINVOKER                           = 458
	MySqlParserIO                                = 459
	MySqlParserIO_THREAD                         = 460
	MySqlParserIPC                               = 461
	MySqlParserISOLATION                         = 462
	MySqlParserISSUER                            = 463
	MySqlParserJSON                              = 464
	MySqlParserKEY_BLOCK_SIZE                    = 465
	MySqlParserLANGUAGE                          = 466
	MySqlParserLAST                              = 467
	MySqlParserLEAVES                            = 468
	MySqlParserLESS                              = 469
	MySqlParserLEVEL                             = 470
	MySqlParserLIST                              = 471
	MySqlParserLOCAL                             = 472
	MySqlParserLOGFILE                           = 473
	MySqlParserLOGS                              = 474
	MySqlParserMASTER                            = 475
	MySqlParserMASTER_AUTO_POSITION              = 476
	MySqlParserMASTER_CONNECT_RETRY              = 477
	MySqlParserMASTER_DELAY                      = 478
	MySqlParserMASTER_HEARTBEAT_PERIOD           = 479
	MySqlParserMASTER_HOST                       = 480
	MySqlParserMASTER_LOG_FILE                   = 481
	MySqlParserMASTER_LOG_POS                    = 482
	MySqlParserMASTER_PASSWORD                   = 483
	MySqlParserMASTER_PORT                       = 484
	MySqlParserMASTER_RETRY_COUNT                = 485
	MySqlParserMASTER_SSL                        = 486
	MySqlParserMASTER_SSL_CA                     = 487
	MySqlParserMASTER_SSL_CAPATH                 = 488
	MySqlParserMASTER_SSL_CERT                   = 489
	MySqlParserMASTER_SSL_CIPHER                 = 490
	MySqlParserMASTER_SSL_CRL                    = 491
	MySqlParserMASTER_SSL_CRLPATH                = 492
	MySqlParserMASTER_SSL_KEY                    = 493
	MySqlParserMASTER_TLS_VERSION                = 494
	MySqlParserMASTER_USER                       = 495
	MySqlParserMAX_CONNECTIONS_PER_HOUR          = 496
	MySqlParserMAX_QUERIES_PER_HOUR              = 497
	MySqlParserMAX_ROWS                          = 498
	MySqlParserMAX_SIZE                          = 499
	MySqlParserMAX_UPDATES_PER_HOUR              = 500
	MySqlParserMAX_USER_CONNECTIONS              = 501
	MySqlParserMEDIUM                            = 502
	MySqlParserMEMBER                            = 503
	MySqlParserMERGE                             = 504
	MySqlParserMESSAGE_TEXT                      = 505
	MySqlParserMID                               = 506
	MySqlParserMIGRATE                           = 507
	MySqlParserMIN_ROWS                          = 508
	MySqlParserMODE                              = 509
	MySqlParserMODIFY                            = 510
	MySqlParserMUTEX                             = 511
	MySqlParserMYSQL                             = 512
	MySqlParserMYSQL_ERRNO                       = 513
	MySqlParserNAME                              = 514
	MySqlParserNAMES                             = 515
	MySqlParserNCHAR                             = 516
	MySqlParserNEVER                             = 517
	MySqlParserNEXT                              = 518
	MySqlParserNO                                = 519
	MySqlParserNOCACHE                           = 520
	MySqlParserNOCOPY                            = 521
	MySqlParserNOCYCLE                           = 522
	MySqlParserNOMAXVALUE                        = 523
	MySqlParserNOMINVALUE                        = 524
	MySqlParserNOWAIT                            = 525
	MySqlParserNODEGROUP                         = 526
	MySqlParserNONE                              = 527
	MySqlParserODBC                              = 528
	MySqlParserOFFLINE                           = 529
	MySqlParserOFFSET                            = 530
	MySqlParserOF                                = 531
	MySqlParserOJ                                = 532
	MySqlParserOLD_PASSWORD                      = 533
	MySqlParserONE                               = 534
	MySqlParserONLINE                            = 535
	MySqlParserONLY                              = 536
	MySqlParserOPEN                              = 537
	MySqlParserOPTIMIZER_COSTS                   = 538
	MySqlParserOPTIONS                           = 539
	MySqlParserOWNER                             = 540
	MySqlParserPACK_KEYS                         = 541
	MySqlParserPAGE                              = 542
	MySqlParserPAGE_COMPRESSED                   = 543
	MySqlParserPAGE_COMPRESSION_LEVEL            = 544
	MySqlParserPARSER                            = 545
	MySqlParserPARTIAL                           = 546
	MySqlParserPARTITIONING                      = 547
	MySqlParserPARTITIONS                        = 548
	MySqlParserPASSWORD                          = 549
	MySqlParserPASSWORD_LOCK_TIME                = 550
	MySqlParserPHASE                             = 551
	MySqlParserPLUGIN                            = 552
	MySqlParserPLUGIN_DIR                        = 553
	MySqlParserPLUGINS                           = 554
	MySqlParserPORT                              = 555
	MySqlParserPRECEDES                          = 556
	MySqlParserPRECEDING                         = 557
	MySqlParserPREPARE                           = 558
	MySqlParserPRESERVE                          = 559
	MySqlParserPREV                              = 560
	MySqlParserPROCESSLIST                       = 561
	MySqlParserPROFILE                           = 562
	MySqlParserPROFILES                          = 563
	MySqlParserPROXY                             = 564
	MySqlParserQUERY                             = 565
	MySqlParserQUICK                             = 566
	MySqlParserREBUILD                           = 567
	MySqlParserRECOVER                           = 568
	MySqlParserRECURSIVE                         = 569
	MySqlParserREDO_BUFFER_SIZE                  = 570
	MySqlParserREDUNDANT                         = 571
	MySqlParserRELAY                             = 572
	MySqlParserRELAY_LOG_FILE                    = 573
	MySqlParserRELAY_LOG_POS                     = 574
	MySqlParserRELAYLOG                          = 575
	MySqlParserREMOVE                            = 576
	MySqlParserREORGANIZE                        = 577
	MySqlParserREPAIR                            = 578
	MySqlParserREPLICATE_DO_DB                   = 579
	MySqlParserREPLICATE_DO_TABLE                = 580
	MySqlParserREPLICATE_IGNORE_DB               = 581
	MySqlParserREPLICATE_IGNORE_TABLE            = 582
	MySqlParserREPLICATE_REWRITE_DB              = 583
	MySqlParserREPLICATE_WILD_DO_TABLE           = 584
	MySqlParserREPLICATE_WILD_IGNORE_TABLE       = 585
	MySqlParserREPLICATION                       = 586
	MySqlParserRESET                             = 587
	MySqlParserRESTART                           = 588
	MySqlParserRESUME                            = 589
	MySqlParserRETURNED_SQLSTATE                 = 590
	MySqlParserRETURNING                         = 591
	MySqlParserRETURNS                           = 592
	MySqlParserREUSE                             = 593
	MySqlParserROLE                              = 594
	MySqlParserROLLBACK                          = 595
	MySqlParserROLLUP                            = 596
	MySqlParserROTATE                            = 597
	MySqlParserROW                               = 598
	MySqlParserROWS                              = 599
	MySqlParserROW_FORMAT                        = 600
	MySqlParserRTREE                             = 601
	MySqlParserSAVEPOINT                         = 602
	MySqlParserSCHEDULE                          = 603
	MySqlParserSECURITY                          = 604
	MySqlParserSEQUENCE                          = 605
	MySqlParserSERVER                            = 606
	MySqlParserSESSION                           = 607
	MySqlParserSHARE                             = 608
	MySqlParserSHARED                            = 609
	MySqlParserSIGNED                            = 610
	MySqlParserSIMPLE                            = 611
	MySqlParserSLAVE                             = 612
	MySqlParserSLOW                              = 613
	MySqlParserSNAPSHOT                          = 614
	MySqlParserSOCKET                            = 615
	MySqlParserSOME                              = 616
	MySqlParserSONAME                            = 617
	MySqlParserSOUNDS                            = 618
	MySqlParserSOURCE                            = 619
	MySqlParserSQL_AFTER_GTIDS                   = 620
	MySqlParserSQL_AFTER_MTS_GAPS                = 621
	MySqlParserSQL_BEFORE_GTIDS                  = 622
	MySqlParserSQL_BUFFER_RESULT                 = 623
	MySqlParserSQL_CACHE                         = 624
	MySqlParserSQL_NO_CACHE                      = 625
	MySqlParserSQL_THREAD                        = 626
	MySqlParserSTART                             = 627
	MySqlParserSTARTS                            = 628
	MySqlParserSTATS_AUTO_RECALC                 = 629
	MySqlParserSTATS_PERSISTENT                  = 630
	MySqlParserSTATS_SAMPLE_PAGES                = 631
	MySqlParserSTATUS                            = 632
	MySqlParserSTOP                              = 633
	MySqlParserSTORAGE                           = 634
	MySqlParserSTORED                            = 635
	MySqlParserSTRING                            = 636
	MySqlParserSUBCLASS_ORIGIN                   = 637
	MySqlParserSUBJECT                           = 638
	MySqlParserSUBPARTITION                      = 639
	MySqlParserSUBPARTITIONS                     = 640
	MySqlParserSUSPEND                           = 641
	MySqlParserSWAPS                             = 642
	MySqlParserSWITCHES                          = 643
	MySqlParserTABLE_NAME                        = 644
	MySqlParserTABLESPACE                        = 645
	MySqlParserTABLE_TYPE                        = 646
	MySqlParserTEMPORARY                         = 647
	MySqlParserTEMPTABLE                         = 648
	MySqlParserTHAN                              = 649
	MySqlParserTRADITIONAL                       = 650
	MySqlParserTRANSACTION                       = 651
	MySqlParserTRANSACTIONAL                     = 652
	MySqlParserTRIGGERS                          = 653
	MySqlParserTRUNCATE                          = 654
	MySqlParserUNBOUNDED                         = 655
	MySqlParserUNDEFINED                         = 656
	MySqlParserUNDOFILE                          = 657
	MySqlParserUNDO_BUFFER_SIZE                  = 658
	MySqlParserUNINSTALL                         = 659
	MySqlParserUNKNOWN                           = 660
	MySqlParserUNTIL                             = 661
	MySqlParserUPGRADE                           = 662
	MySqlParserUSER                              = 663
	MySqlParserUSE_FRM                           = 664
	MySqlParserUSER_RESOURCES                    = 665
	MySqlParserVALIDATION                        = 666
	MySqlParserVALUE                             = 667
	MySqlParserVARIABLES                         = 668
	MySqlParserVIEW                              = 669
	MySqlParserVIRTUAL                           = 670
	MySqlParserVISIBLE                           = 671
	MySqlParserWAIT                              = 672
	MySqlParserWARNINGS                          = 673
	MySqlParserWINDOW                            = 674
	MySqlParserWITHOUT                           = 675
	MySqlParserWORK                              = 676
	MySqlParserWRAPPER                           = 677
	MySqlParserX509                              = 678
	MySqlParserXA                                = 679
	MySqlParserXML                               = 680
	MySqlParserYES                               = 681
	MySqlParserEUR                               = 682
	MySqlParserUSA                               = 683
	MySqlParserJIS                               = 684
	MySqlParserISO                               = 685
	MySqlParserINTERNAL                          = 686
	MySqlParserQUARTER                           = 687
	MySqlParserMONTH                             = 688
	MySqlParserDAY                               = 689
	MySqlParserHOUR                              = 690
	MySqlParserMINUTE                            = 691
	MySqlParserWEEK                              = 692
	MySqlParserSECOND                            = 693
	MySqlParserMICROSECOND                       = 694
	MySqlParserADMIN                             = 695
	MySqlParserAPPLICATION_PASSWORD_ADMIN        = 696
	MySqlParserAUDIT_ADMIN                       = 697
	MySqlParserBACKUP_ADMIN                      = 698
	MySqlParserBINLOG_ADMIN                      = 699
	MySqlParserBINLOG_ENCRYPTION_ADMIN           = 700
	MySqlParserCLONE_ADMIN                       = 701
	MySqlParserCONNECTION_ADMIN                  = 702
	MySqlParserENCRYPTION_KEY_ADMIN              = 703
	MySqlParserEXECUTE                           = 704
	MySqlParserFILE                              = 705
	MySqlParserFIREWALL_ADMIN                    = 706
	MySqlParserFIREWALL_USER                     = 707
	MySqlParserFLUSH_OPTIMIZER_COSTS             = 708
	MySqlParserFLUSH_STATUS                      = 709
	MySqlParserFLUSH_TABLES                      = 710
	MySqlParserFLUSH_USER_RESOURCES              = 711
	MySqlParserGROUP_REPLICATION_ADMIN           = 712
	MySqlParserINNODB_REDO_LOG_ARCHIVE           = 713
	MySqlParserINNODB_REDO_LOG_ENABLE            = 714
	MySqlParserINVOKE                            = 715
	MySqlParserLAMBDA                            = 716
	MySqlParserNDB_STORED_USER                   = 717
	MySqlParserPASSWORDLESS_USER_ADMIN           = 718
	MySqlParserPERSIST_RO_VARIABLES_ADMIN        = 719
	MySqlParserPRIVILEGES                        = 720
	MySqlParserPROCESS                           = 721
	MySqlParserRELOAD                            = 722
	MySqlParserREPLICATION_APPLIER               = 723
	MySqlParserREPLICATION_SLAVE_ADMIN           = 724
	MySqlParserRESOURCE_GROUP_ADMIN              = 725
	MySqlParserRESOURCE_GROUP_USER               = 726
	MySqlParserROLE_ADMIN                        = 727
	MySqlParserROUTINE                           = 728
	MySqlParserS3                                = 729
	MySqlParserSERVICE_CONNECTION_ADMIN          = 730
	MySqlParserSESSION_VARIABLES_ADMIN           = 731
	MySqlParserSET_USER_ID                       = 732
	MySqlParserSHOW_ROUTINE                      = 733
	MySqlParserSHUTDOWN                          = 734
	MySqlParserSUPER                             = 735
	MySqlParserSYSTEM_VARIABLES_ADMIN            = 736
	MySqlParserTABLES                            = 737
	MySqlParserTABLE_ENCRYPTION_ADMIN            = 738
	MySqlParserVERSION_TOKEN_ADMIN               = 739
	MySqlParserXA_RECOVER_ADMIN                  = 740
	MySqlParserARMSCII8                          = 741
	MySqlParserASCII                             = 742
	MySqlParserBIG5                              = 743
	MySqlParserCP1250                            = 744
	MySqlParserCP1251                            = 745
	MySqlParserCP1256                            = 746
	MySqlParserCP1257                            = 747
	MySqlParserCP850                             = 748
	MySqlParserCP852                             = 749
	MySqlParserCP866                             = 750
	MySqlParserCP932                             = 751
	MySqlParserDEC8                              = 752
	MySqlParserEUCJPMS                           = 753
	MySqlParserEUCKR                             = 754
	MySqlParserGB18030                           = 755
	MySqlParserGB2312                            = 756
	MySqlParserGBK                               = 757
	MySqlParserGEOSTD8                           = 758
	MySqlParserGREEK                             = 759
	MySqlParserHEBREW                            = 760
	MySqlParserHP8                               = 761
	MySqlParserKEYBCS2                           = 762
	MySqlParserKOI8R                             = 763
	MySqlParserKOI8U                             = 764
	MySqlParserLATIN1                            = 765
	MySqlParserLATIN2                            = 766
	MySqlParserLATIN5                            = 767
	MySqlParserLATIN7                            = 768
	MySqlParserMACCE                             = 769
	MySqlParserMACROMAN                          = 770
	MySqlParserSJIS                              = 771
	MySqlParserSWE7                              = 772
	MySqlParserTIS620                            = 773
	MySqlParserUCS2                              = 774
	MySqlParserUJIS                              = 775
	MySqlParserUTF16                             = 776
	MySqlParserUTF16LE                           = 777
	MySqlParserUTF32                             = 778
	MySqlParserUTF8                              = 779
	MySqlParserUTF8MB3                           = 780
	MySqlParserUTF8MB4                           = 781
	MySqlParserARCHIVE                           = 782
	MySqlParserBLACKHOLE                         = 783
	MySqlParserCSV                               = 784
	MySqlParserFEDERATED                         = 785
	MySqlParserINNODB                            = 786
	MySqlParserMEMORY                            = 787
	MySqlParserMRG_MYISAM                        = 788
	MySqlParserMYISAM                            = 789
	MySqlParserNDB                               = 790
	MySqlParserNDBCLUSTER                        = 791
	MySqlParserPERFORMANCE_SCHEMA                = 792
	MySqlParserTOKUDB                            = 793
	MySqlParserREPEATABLE                        = 794
	MySqlParserCOMMITTED                         = 795
	MySqlParserUNCOMMITTED                       = 796
	MySqlParserSERIALIZABLE                      = 797
	MySqlParserGEOMETRYCOLLECTION                = 798
	MySqlParserGEOMCOLLECTION                    = 799
	MySqlParserGEOMETRY                          = 800
	MySqlParserLINESTRING                        = 801
	MySqlParserMULTILINESTRING                   = 802
	MySqlParserMULTIPOINT                        = 803
	MySqlParserMULTIPOLYGON                      = 804
	MySqlParserPOINT                             = 805
	MySqlParserPOLYGON                           = 806
	MySqlParserABS                               = 807
	MySqlParserACOS                              = 808
	MySqlParserADDDATE                           = 809
	MySqlParserADDTIME                           = 810
	MySqlParserAES_DECRYPT                       = 811
	MySqlParserAES_ENCRYPT                       = 812
	MySqlParserAREA                              = 813
	MySqlParserASBINARY                          = 814
	MySqlParserASIN                              = 815
	MySqlParserASTEXT                            = 816
	MySqlParserASWKB                             = 817
	MySqlParserASWKT                             = 818
	MySqlParserASYMMETRIC_DECRYPT                = 819
	MySqlParserASYMMETRIC_DERIVE                 = 820
	MySqlParserASYMMETRIC_ENCRYPT                = 821
	MySqlParserASYMMETRIC_SIGN                   = 822
	MySqlParserASYMMETRIC_VERIFY                 = 823
	MySqlParserATAN                              = 824
	MySqlParserATAN2                             = 825
	MySqlParserBENCHMARK                         = 826
	MySqlParserBIN                               = 827
	MySqlParserBIT_COUNT                         = 828
	MySqlParserBIT_LENGTH                        = 829
	MySqlParserBUFFER                            = 830
	MySqlParserCATALOG_NAME                      = 831
	MySqlParserCEIL                              = 832
	MySqlParserCEILING                           = 833
	MySqlParserCENTROID                          = 834
	MySqlParserCHARACTER_LENGTH                  = 835
	MySqlParserCHARSET                           = 836
	MySqlParserCHAR_LENGTH                       = 837
	MySqlParserCOERCIBILITY                      = 838
	MySqlParserCOLLATION                         = 839
	MySqlParserCOMPRESS                          = 840
	MySqlParserCONCAT                            = 841
	MySqlParserCONCAT_WS                         = 842
	MySqlParserCONNECTION_ID                     = 843
	MySqlParserCONV                              = 844
	MySqlParserCONVERT_TZ                        = 845
	MySqlParserCOS                               = 846
	MySqlParserCOT                               = 847
	MySqlParserCRC32                             = 848
	MySqlParserCREATE_ASYMMETRIC_PRIV_KEY        = 849
	MySqlParserCREATE_ASYMMETRIC_PUB_KEY         = 850
	MySqlParserCREATE_DH_PARAMETERS              = 851
	MySqlParserCREATE_DIGEST                     = 852
	MySqlParserCROSSES                           = 853
	MySqlParserDATEDIFF                          = 854
	MySqlParserDATE_FORMAT                       = 855
	MySqlParserDAYNAME                           = 856
	MySqlParserDAYOFMONTH                        = 857
	MySqlParserDAYOFWEEK                         = 858
	MySqlParserDAYOFYEAR                         = 859
	MySqlParserDECODE                            = 860
	MySqlParserDEGREES                           = 861
	MySqlParserDES_DECRYPT                       = 862
	MySqlParserDES_ENCRYPT                       = 863
	MySqlParserDIMENSION                         = 864
	MySqlParserDISJOINT                          = 865
	MySqlParserELT                               = 866
	MySqlParserENCODE                            = 867
	MySqlParserENCRYPT                           = 868
	MySqlParserENDPOINT                          = 869
	MySqlParserENGINE_ATTRIBUTE                  = 870
	MySqlParserENVELOPE                          = 871
	MySqlParserEQUALS                            = 872
	MySqlParserEXP                               = 873
	MySqlParserEXPORT_SET                        = 874
	MySqlParserEXTERIORRING                      = 875
	MySqlParserEXTRACTVALUE                      = 876
	MySqlParserFIELD                             = 877
	MySqlParserFIND_IN_SET                       = 878
	MySqlParserFLOOR                             = 879
	MySqlParserFORMAT                            = 880
	MySqlParserFOUND_ROWS                        = 881
	MySqlParserFROM_BASE64                       = 882
	MySqlParserFROM_DAYS                         = 883
	MySqlParserFROM_UNIXTIME                     = 884
	MySqlParserGEOMCOLLFROMTEXT                  = 885
	MySqlParserGEOMCOLLFROMWKB                   = 886
	MySqlParserGEOMETRYCOLLECTIONFROMTEXT        = 887
	MySqlParserGEOMETRYCOLLECTIONFROMWKB         = 888
	MySqlParserGEOMETRYFROMTEXT                  = 889
	MySqlParserGEOMETRYFROMWKB                   = 890
	MySqlParserGEOMETRYN                         = 891
	MySqlParserGEOMETRYTYPE                      = 892
	MySqlParserGEOMFROMTEXT                      = 893
	MySqlParserGEOMFROMWKB                       = 894
	MySqlParserGET_FORMAT                        = 895
	MySqlParserGET_LOCK                          = 896
	MySqlParserGLENGTH                           = 897
	MySqlParserGREATEST                          = 898
	MySqlParserGTID_SUBSET                       = 899
	MySqlParserGTID_SUBTRACT                     = 900
	MySqlParserHEX                               = 901
	MySqlParserIFNULL                            = 902
	MySqlParserINET6_ATON                        = 903
	MySqlParserINET6_NTOA                        = 904
	MySqlParserINET_ATON                         = 905
	MySqlParserINET_NTOA                         = 906
	MySqlParserINSTR                             = 907
	MySqlParserINTERIORRINGN                     = 908
	MySqlParserINTERSECTS                        = 909
	MySqlParserISCLOSED                          = 910
	MySqlParserISEMPTY                           = 911
	MySqlParserISNULL                            = 912
	MySqlParserISSIMPLE                          = 913
	MySqlParserIS_FREE_LOCK                      = 914
	MySqlParserIS_IPV4                           = 915
	MySqlParserIS_IPV4_COMPAT                    = 916
	MySqlParserIS_IPV4_MAPPED                    = 917
	MySqlParserIS_IPV6                           = 918
	MySqlParserIS_USED_LOCK                      = 919
	MySqlParserLAST_INSERT_ID                    = 920
	MySqlParserLCASE                             = 921
	MySqlParserLEAST                             = 922
	MySqlParserLENGTH                            = 923
	MySqlParserLINEFROMTEXT                      = 924
	MySqlParserLINEFROMWKB                       = 925
	MySqlParserLINESTRINGFROMTEXT                = 926
	MySqlParserLINESTRINGFROMWKB                 = 927
	MySqlParserLN                                = 928
	MySqlParserLOAD_FILE                         = 929
	MySqlParserLOCATE                            = 930
	MySqlParserLOG                               = 931
	MySqlParserLOG10                             = 932
	MySqlParserLOG2                              = 933
	MySqlParserLOWER                             = 934
	MySqlParserLPAD                              = 935
	MySqlParserLTRIM                             = 936
	MySqlParserMAKEDATE                          = 937
	MySqlParserMAKETIME                          = 938
	MySqlParserMAKE_SET                          = 939
	MySqlParserMASTER_POS_WAIT                   = 940
	MySqlParserMBRCONTAINS                       = 941
	MySqlParserMBRDISJOINT                       = 942
	MySqlParserMBREQUAL                          = 943
	MySqlParserMBRINTERSECTS                     = 944
	MySqlParserMBROVERLAPS                       = 945
	MySqlParserMBRTOUCHES                        = 946
	MySqlParserMBRWITHIN                         = 947
	MySqlParserMD5                               = 948
	MySqlParserMLINEFROMTEXT                     = 949
	MySqlParserMLINEFROMWKB                      = 950
	MySqlParserMONTHNAME                         = 951
	MySqlParserMPOINTFROMTEXT                    = 952
	MySqlParserMPOINTFROMWKB                     = 953
	MySqlParserMPOLYFROMTEXT                     = 954
	MySqlParserMPOLYFROMWKB                      = 955
	MySqlParserMULTILINESTRINGFROMTEXT           = 956
	MySqlParserMULTILINESTRINGFROMWKB            = 957
	MySqlParserMULTIPOINTFROMTEXT                = 958
	MySqlParserMULTIPOINTFROMWKB                 = 959
	MySqlParserMULTIPOLYGONFROMTEXT              = 960
	MySqlParserMULTIPOLYGONFROMWKB               = 961
	MySqlParserNAME_CONST                        = 962
	MySqlParserNULLIF                            = 963
	MySqlParserNUMGEOMETRIES                     = 964
	MySqlParserNUMINTERIORRINGS                  = 965
	MySqlParserNUMPOINTS                         = 966
	MySqlParserOCT                               = 967
	MySqlParserOCTET_LENGTH                      = 968
	MySqlParserORD                               = 969
	MySqlParserOVERLAPS                          = 970
	MySqlParserPERIOD_ADD                        = 971
	MySqlParserPERIOD_DIFF                       = 972
	MySqlParserPI                                = 973
	MySqlParserPOINTFROMTEXT                     = 974
	MySqlParserPOINTFROMWKB                      = 975
	MySqlParserPOINTN                            = 976
	MySqlParserPOLYFROMTEXT                      = 977
	MySqlParserPOLYFROMWKB                       = 978
	MySqlParserPOLYGONFROMTEXT                   = 979
	MySqlParserPOLYGONFROMWKB                    = 980
	MySqlParserPOW                               = 981
	MySqlParserPOWER                             = 982
	MySqlParserQUOTE                             = 983
	MySqlParserRADIANS                           = 984
	MySqlParserRAND                              = 985
	MySqlParserRANDOM_BYTES                      = 986
	MySqlParserRELEASE_LOCK                      = 987
	MySqlParserREVERSE                           = 988
	MySqlParserROUND                             = 989
	MySqlParserROW_COUNT                         = 990
	MySqlParserRPAD                              = 991
	MySqlParserRTRIM                             = 992
	MySqlParserSEC_TO_TIME                       = 993
	MySqlParserSECONDARY_ENGINE_ATTRIBUTE        = 994
	MySqlParserSESSION_USER                      = 995
	MySqlParserSHA                               = 996
	MySqlParserSHA1                              = 997
	MySqlParserSHA2                              = 998
	MySqlParserSCHEMA_NAME                       = 999
	MySqlParserSIGN                              = 1000
	MySqlParserSIN                               = 1001
	MySqlParserSLEEP                             = 1002
	MySqlParserSOUNDEX                           = 1003
	MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS       = 1004
	MySqlParserSQRT                              = 1005
	MySqlParserSRID                              = 1006
	MySqlParserSTARTPOINT                        = 1007
	MySqlParserSTRCMP                            = 1008
	MySqlParserSTR_TO_DATE                       = 1009
	MySqlParserST_AREA                           = 1010
	MySqlParserST_ASBINARY                       = 1011
	MySqlParserST_ASTEXT                         = 1012
	MySqlParserST_ASWKB                          = 1013
	MySqlParserST_ASWKT                          = 1014
	MySqlParserST_BUFFER                         = 1015
	MySqlParserST_CENTROID                       = 1016
	MySqlParserST_CONTAINS                       = 1017
	MySqlParserST_CROSSES                        = 1018
	MySqlParserST_DIFFERENCE                     = 1019
	MySqlParserST_DIMENSION                      = 1020
	MySqlParserST_DISJOINT                       = 1021
	MySqlParserST_DISTANCE                       = 1022
	MySqlParserST_ENDPOINT                       = 1023
	MySqlParserST_ENVELOPE                       = 1024
	MySqlParserST_EQUALS                         = 1025
	MySqlParserST_EXTERIORRING                   = 1026
	MySqlParserST_GEOMCOLLFROMTEXT               = 1027
	MySqlParserST_GEOMCOLLFROMTXT                = 1028
	MySqlParserST_GEOMCOLLFROMWKB                = 1029
	MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT     = 1030
	MySqlParserST_GEOMETRYCOLLECTIONFROMWKB      = 1031
	MySqlParserST_GEOMETRYFROMTEXT               = 1032
	MySqlParserST_GEOMETRYFROMWKB                = 1033
	MySqlParserST_GEOMETRYN                      = 1034
	MySqlParserST_GEOMETRYTYPE                   = 1035
	MySqlParserST_GEOMFROMTEXT                   = 1036
	MySqlParserST_GEOMFROMWKB                    = 1037
	MySqlParserST_INTERIORRINGN                  = 1038
	MySqlParserST_INTERSECTION                   = 1039
	MySqlParserST_INTERSECTS                     = 1040
	MySqlParserST_ISCLOSED                       = 1041
	MySqlParserST_ISEMPTY                        = 1042
	MySqlParserST_ISSIMPLE                       = 1043
	MySqlParserST_LINEFROMTEXT                   = 1044
	MySqlParserST_LINEFROMWKB                    = 1045
	MySqlParserST_LINESTRINGFROMTEXT             = 1046
	MySqlParserST_LINESTRINGFROMWKB              = 1047
	MySqlParserST_NUMGEOMETRIES                  = 1048
	MySqlParserST_NUMINTERIORRING                = 1049
	MySqlParserST_NUMINTERIORRINGS               = 1050
	MySqlParserST_NUMPOINTS                      = 1051
	MySqlParserST_OVERLAPS                       = 1052
	MySqlParserST_POINTFROMTEXT                  = 1053
	MySqlParserST_POINTFROMWKB                   = 1054
	MySqlParserST_POINTN                         = 1055
	MySqlParserST_POLYFROMTEXT                   = 1056
	MySqlParserST_POLYFROMWKB                    = 1057
	MySqlParserST_POLYGONFROMTEXT                = 1058
	MySqlParserST_POLYGONFROMWKB                 = 1059
	MySqlParserST_SRID                           = 1060
	MySqlParserST_STARTPOINT                     = 1061
	MySqlParserST_SYMDIFFERENCE                  = 1062
	MySqlParserST_TOUCHES                        = 1063
	MySqlParserST_UNION                          = 1064
	MySqlParserST_WITHIN                         = 1065
	MySqlParserST_X                              = 1066
	MySqlParserST_Y                              = 1067
	MySqlParserSUBDATE                           = 1068
	MySqlParserSUBSTRING_INDEX                   = 1069
	MySqlParserSUBTIME                           = 1070
	MySqlParserSYSTEM_USER                       = 1071
	MySqlParserTAN                               = 1072
	MySqlParserTIMEDIFF                          = 1073
	MySqlParserTIMESTAMPADD                      = 1074
	MySqlParserTIMESTAMPDIFF                     = 1075
	MySqlParserTIME_FORMAT                       = 1076
	MySqlParserTIME_TO_SEC                       = 1077
	MySqlParserTOUCHES                           = 1078
	MySqlParserTO_BASE64                         = 1079
	MySqlParserTO_DAYS                           = 1080
	MySqlParserTO_SECONDS                        = 1081
	MySqlParserUCASE                             = 1082
	MySqlParserUNCOMPRESS                        = 1083
	MySqlParserUNCOMPRESSED_LENGTH               = 1084
	MySqlParserUNHEX                             = 1085
	MySqlParserUNIX_TIMESTAMP                    = 1086
	MySqlParserUPDATEXML                         = 1087
	MySqlParserUPPER                             = 1088
	MySqlParserUUID                              = 1089
	MySqlParserUUID_SHORT                        = 1090
	MySqlParserVALIDATE_PASSWORD_STRENGTH        = 1091
	MySqlParserVERSION                           = 1092
	MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1093
	MySqlParserWEEKDAY                           = 1094
	MySqlParserWEEKOFYEAR                        = 1095
	MySqlParserWEIGHT_STRING                     = 1096
	MySqlParserWITHIN                            = 1097
	MySqlParserYEARWEEK                          = 1098
	MySqlParserY_FUNCTION                        = 1099
	MySqlParserX_FUNCTION                        = 1100
	MySqlParserVAR_ASSIGN                        = 1101
	MySqlParserPLUS_ASSIGN                       = 1102
	MySqlParserMINUS_ASSIGN                      = 1103
	MySqlParserMULT_ASSIGN                       = 1104
	MySqlParserDIV_ASSIGN                        = 1105
	MySqlParserMOD_ASSIGN                        = 1106
	MySqlParserAND_ASSIGN                        = 1107
	MySqlParserXOR_ASSIGN                        = 1108
	MySqlParserOR_ASSIGN                         = 1109
	MySqlParserSTAR                              = 1110
	MySqlParserDIVIDE                            = 1111
	MySqlParserMODULE                            = 1112
	MySqlParserPLUS                              = 1113
	MySqlParserMINUS                             = 1114
	MySqlParserDIV                               = 1115
	MySqlParserMOD                               = 1116
	MySqlParserEQUAL_SYMBOL                      = 1117
	MySqlParserGREATER_SYMBOL                    = 1118
	MySqlParserLESS_SYMBOL                       = 1119
	MySqlParserEXCLAMATION_SYMBOL                = 1120
	MySqlParserBIT_NOT_OP                        = 1121
	MySqlParserBIT_OR_OP                         = 1122
	MySqlParserBIT_AND_OP                        = 1123
	MySqlParserBIT_XOR_OP                        = 1124
	MySqlParserDOT                               = 1125
	MySqlParserLR_BRACKET                        = 1126
	MySqlParserRR_BRACKET                        = 1127
	MySqlParserCOMMA                             = 1128
	MySqlParserSEMI                              = 1129
	MySqlParserAT_SIGN                           = 1130
	MySqlParserZERO_DECIMAL                      = 1131
	MySqlParserONE_DECIMAL                       = 1132
	MySqlParserTWO_DECIMAL                       = 1133
	MySqlParserSINGLE_QUOTE_SYMB                 = 1134
	MySqlParserDOUBLE_QUOTE_SYMB                 = 1135
	MySqlParserREVERSE_QUOTE_SYMB                = 1136
	MySqlParserCOLON_SYMB                        = 1137
	MySqlParserCHARSET_REVERSE_QOUTE_STRING      = 1138
	MySqlParserFILESIZE_LITERAL                  = 1139
	MySqlParserSTART_NATIONAL_STRING_LITERAL     = 1140
	MySqlParserSTRING_LITERAL                    = 1141
	MySqlParserDECIMAL_LITERAL                   = 1142
	MySqlParserHEXADECIMAL_LITERAL               = 1143
	MySqlParserREAL_LITERAL                      = 1144
	MySqlParserNULL_SPEC_LITERAL                 = 1145
	MySqlParserBIT_STRING                        = 1146
	MySqlParserSTRING_CHARSET_NAME               = 1147
	MySqlParserDOT_ID                            = 1148
	MySqlParserID                                = 1149
	MySqlParserREVERSE_QUOTE_ID                  = 1150
	MySqlParserSTRING_USER_NAME                  = 1151
	MySqlParserIP_ADDRESS                        = 1152
	MySqlParserLOCAL_ID                          = 1153
	MySqlParserGLOBAL_ID                         = 1154
	MySqlParserERROR_RECONGNIGION                = 1155
)

// MySqlParser rules.
const (
	MySqlParserRULE_root                      = 0
	MySqlParserRULE_sqlStatements             = 1
	MySqlParserRULE_sqlStatement              = 2
	MySqlParserRULE_emptyStatement_           = 3
	MySqlParserRULE_dmlStatement              = 4
	MySqlParserRULE_selectStatement           = 5
	MySqlParserRULE_lockClause                = 6
	MySqlParserRULE_tableSources              = 7
	MySqlParserRULE_tableSource               = 8
	MySqlParserRULE_querySpecification        = 9
	MySqlParserRULE_selectSpec                = 10
	MySqlParserRULE_selectElements            = 11
	MySqlParserRULE_selectElement             = 12
	MySqlParserRULE_fromClause                = 13
	MySqlParserRULE_limitClause               = 14
	MySqlParserRULE_limitClauseAtom           = 15
	MySqlParserRULE_fullId                    = 16
	MySqlParserRULE_tableName                 = 17
	MySqlParserRULE_fullColumnName            = 18
	MySqlParserRULE_collationName             = 19
	MySqlParserRULE_uid                       = 20
	MySqlParserRULE_simpleId                  = 21
	MySqlParserRULE_dottedId                  = 22
	MySqlParserRULE_decimalLiteral            = 23
	MySqlParserRULE_stringLiteral             = 24
	MySqlParserRULE_booleanLiteral            = 25
	MySqlParserRULE_hexadecimalLiteral        = 26
	MySqlParserRULE_constant                  = 27
	MySqlParserRULE_expressions               = 28
	MySqlParserRULE_functionCall              = 29
	MySqlParserRULE_aggregateWindowedFunction = 30
	MySqlParserRULE_expression                = 31
	MySqlParserRULE_predicate                 = 32
	MySqlParserRULE_expressionAtom            = 33
	MySqlParserRULE_unaryOperator             = 34
	MySqlParserRULE_comparisonOperator        = 35
	MySqlParserRULE_logicalOperator           = 36
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_root
	return p
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(MySqlParserEOF, 0)
}

func (s *RootContext) SqlStatements() ISqlStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementsContext)
}

func (s *RootContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *RootContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Root() (localctx IRootContext) {
	this := p
	_ = this

	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MySqlParserRULE_root)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(75)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSELECT || _la == MySqlParserSEMI {
		{
			p.SetState(74)
			p.SqlStatements()
		}

	}
	p.SetState(79)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserMINUS {
		{
			p.SetState(77)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(78)
			p.Match(MySqlParserMINUS)
		}

	}
	{
		p.SetState(81)
		p.Match(MySqlParserEOF)
	}

	return localctx
}

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatements
	return p
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) AllSqlStatement() []ISqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqlStatementContext); ok {
			len++
		}
	}

	tst := make([]ISqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqlStatementContext); ok {
			tst[i] = t.(ISqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SqlStatement(i int) ISqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *SqlStatementsContext) AllEmptyStatement_() []IEmptyStatement_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			len++
		}
	}

	tst := make([]IEmptyStatement_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEmptyStatement_Context); ok {
			tst[i] = t.(IEmptyStatement_Context)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) EmptyStatement_(i int) IEmptyStatement_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SqlStatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSEMI)
}

func (s *SqlStatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, i)
}

func (s *SqlStatementsContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *SqlStatementsContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SqlStatements() (localctx ISqlStatementsContext) {
	this := p
	_ = this

	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MySqlParserRULE_sqlStatements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(94)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(92)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSELECT:
				{
					p.SetState(83)
					p.SqlStatement()
				}
				p.SetState(86)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserMINUS {
					{
						p.SetState(84)
						p.Match(MySqlParserMINUS)
					}
					{
						p.SetState(85)
						p.Match(MySqlParserMINUS)
					}

				}
				p.SetState(89)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(88)
						p.Match(MySqlParserSEMI)
					}

				}

			case MySqlParserSEMI:
				{
					p.SetState(91)
					p.EmptyStatement_()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(96)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(106)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT:
		{
			p.SetState(97)
			p.SqlStatement()
		}
		p.SetState(103)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			p.SetState(100)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserMINUS {
				{
					p.SetState(98)
					p.Match(MySqlParserMINUS)
				}
				{
					p.SetState(99)
					p.Match(MySqlParserMINUS)
				}

			}
			{
				p.SetState(102)
				p.Match(MySqlParserSEMI)
			}

		}

	case MySqlParserSEMI:
		{
			p.SetState(105)
			p.EmptyStatement_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatement
	return p
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SqlStatement() (localctx ISqlStatementContext) {
	this := p
	_ = this

	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MySqlParserRULE_sqlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(108)
		p.DmlStatement()
	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	this := p
	_ = this

	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MySqlParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(110)
		p.Match(MySqlParserSEMI)
	}

	return localctx
}

// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDmlStatementContext differentiates from other interfaces.
	IsDmlStatementContext()
}

type DmlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext {
	var p = new(DmlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dmlStatement
	return p
}

func (*DmlStatementContext) IsDmlStatementContext() {}

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext {
	var p = new(DmlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dmlStatement

	return p
}

func (s *DmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DmlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDmlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DmlStatement() (localctx IDmlStatementContext) {
	this := p
	_ = this

	localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MySqlParserRULE_dmlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(112)
		p.SelectStatement()
	}

	return localctx
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectStatement
	return p
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) CopyFrom(ctx *SelectStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimpleSelectContext struct {
	*SelectStatementContext
}

func NewSimpleSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleSelectContext {
	var p = new(SimpleSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *SimpleSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *SimpleSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *SimpleSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectStatement() (localctx ISelectStatementContext) {
	this := p
	_ = this

	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MySqlParserRULE_selectStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewSimpleSelectContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(114)
		p.QuerySpecification()
	}
	p.SetState(116)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR || _la == MySqlParserLOCK {
		{
			p.SetState(115)
			p.LockClause()
		}

	}

	return localctx
}

// ILockClauseContext is an interface to support dynamic dispatch.
type ILockClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLockClauseContext differentiates from other interfaces.
	IsLockClauseContext()
}

type LockClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockClauseContext() *LockClauseContext {
	var p = new(LockClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lockClause
	return p
}

func (*LockClauseContext) IsLockClauseContext() {}

func NewLockClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockClauseContext {
	var p = new(LockClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockClause

	return p
}

func (s *LockClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *LockClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *LockClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *LockClauseContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *LockClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *LockClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LockClause() (localctx ILockClauseContext) {
	this := p
	_ = this

	localctx = NewLockClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MySqlParserRULE_lockClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(124)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(118)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(119)
			p.Match(MySqlParserUPDATE)
		}

	case MySqlParserLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(120)
			p.Match(MySqlParserLOCK)
		}
		{
			p.SetState(121)
			p.Match(MySqlParserIN)
		}
		{
			p.SetState(122)
			p.Match(MySqlParserSHARE)
		}
		{
			p.SetState(123)
			p.Match(MySqlParserMODE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableSourcesContext is an interface to support dynamic dispatch.
type ITableSourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableSourcesContext differentiates from other interfaces.
	IsTableSourcesContext()
}

type TableSourcesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourcesContext() *TableSourcesContext {
	var p = new(TableSourcesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSources
	return p
}

func (*TableSourcesContext) IsTableSourcesContext() {}

func NewTableSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourcesContext {
	var p = new(TableSourcesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSources

	return p
}

func (s *TableSourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourcesContext) AllTableSource() []ITableSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableSourceContext); ok {
			len++
		}
	}

	tst := make([]ITableSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableSourceContext); ok {
			tst[i] = t.(ITableSourceContext)
			i++
		}
	}

	return tst
}

func (s *TableSourcesContext) TableSource(i int) ITableSourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *TableSourcesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TableSourcesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TableSourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSources(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSources() (localctx ITableSourcesContext) {
	this := p
	_ = this

	localctx = NewTableSourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MySqlParserRULE_tableSources)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(126)
		p.TableSource()
	}
	p.SetState(131)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(127)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(128)
			p.TableSource()
		}

		p.SetState(133)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableSourceContext differentiates from other interfaces.
	IsTableSourceContext()
}

type TableSourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceContext() *TableSourceContext {
	var p = new(TableSourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSource
	return p
}

func (*TableSourceContext) IsTableSourceContext() {}

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext {
	var p = new(TableSourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSource

	return p
}

func (s *TableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceContext) CopyFrom(ctx *TableSourceContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableSourceBaseContext struct {
	*TableSourceContext
}

func NewTableSourceBaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceBaseContext {
	var p = new(TableSourceBaseContext)

	p.TableSourceContext = NewEmptyTableSourceContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceBaseContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableSourceBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourceBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSource() (localctx ITableSourceContext) {
	this := p
	_ = this

	localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MySqlParserRULE_tableSource)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewTableSourceBaseContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(134)
		p.TableName()
	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	this := p
	_ = this

	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MySqlParserRULE_querySpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(136)
		p.Match(MySqlParserSELECT)
	}
	p.SetState(140)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(137)
				p.SelectSpec()
			}

		}
		p.SetState(142)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}
	{
		p.SetState(143)
		p.SelectElements()
	}
	p.SetState(145)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFROM {
		{
			p.SetState(144)
			p.FromClause()
		}

	}
	p.SetState(148)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(147)
			p.LimitClause()
		}

	}

	return localctx
}

// ISelectSpecContext is an interface to support dynamic dispatch.
type ISelectSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectSpecContext differentiates from other interfaces.
	IsSelectSpecContext()
}

type SelectSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectSpecContext() *SelectSpecContext {
	var p = new(SelectSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectSpec
	return p
}

func (*SelectSpecContext) IsSelectSpecContext() {}

func NewSelectSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectSpecContext {
	var p = new(SelectSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectSpec

	return p
}

func (s *SelectSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectSpecContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SelectSpecContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *SelectSpecContext) DISTINCTROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCTROW, 0)
}

func (s *SelectSpecContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *SelectSpecContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *SelectSpecContext) SQL_SMALL_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_SMALL_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BIG_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BIG_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *SelectSpecContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *SelectSpecContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *SelectSpecContext) SQL_CALC_FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CALC_FOUND_ROWS, 0)
}

func (s *SelectSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectSpec() (localctx ISelectSpecContext) {
	this := p
	_ = this

	localctx = NewSelectSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MySqlParserRULE_selectSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(158)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL, MySqlParserDISTINCT, MySqlParserDISTINCTROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(150)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1688849860264000) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserHIGH_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(151)
			p.Match(MySqlParserHIGH_PRIORITY)
		}

	case MySqlParserSTRAIGHT_JOIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(152)
			p.Match(MySqlParserSTRAIGHT_JOIN)
		}

	case MySqlParserSQL_SMALL_RESULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(153)
			p.Match(MySqlParserSQL_SMALL_RESULT)
		}

	case MySqlParserSQL_BIG_RESULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(154)
			p.Match(MySqlParserSQL_BIG_RESULT)
		}

	case MySqlParserSQL_BUFFER_RESULT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(155)
			p.Match(MySqlParserSQL_BUFFER_RESULT)
		}

	case MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(156)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_CACHE || _la == MySqlParserSQL_NO_CACHE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserSQL_CALC_FOUND_ROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(157)
			p.Match(MySqlParserSQL_CALC_FOUND_ROWS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token

	// SetStar sets the star token.
	SetStar(antlr.Token)

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	star   antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElements
	return p
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }

func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectElements() (localctx ISelectElementsContext) {
	this := p
	_ = this

	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MySqlParserRULE_selectElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(162)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(160)

			var _m = p.Match(MySqlParserSTAR)

			localctx.(*SelectElementsContext).star = _m
		}

	case 2:
		{
			p.SetState(161)
			p.SelectElement()
		}

	}
	p.SetState(168)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(164)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(165)
			p.SelectElement()
		}

		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElement
	return p
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) CopyFrom(ctx *SelectElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectFunctionElementContext struct {
	*SelectElementContext
}

func NewSelectFunctionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectFunctionElementContext {
	var p = new(SelectFunctionElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectFunctionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFunctionElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectFunctionElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectFunctionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectFunctionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectFunctionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectColumnElementContext struct {
	*SelectElementContext
}

func NewSelectColumnElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectColumnElementContext {
	var p = new(SelectColumnElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectColumnElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *SelectColumnElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectColumnElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectColumnElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectColumnElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectElement() (localctx ISelectElementContext) {
	this := p
	_ = this

	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MySqlParserRULE_selectElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectColumnElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(171)
			p.FullColumnName()
		}
		p.SetState(176)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS || (int64((_la-1138)) & ^0x3f) == 0 && ((int64(1)<<(_la-1138))&6145) != 0 {
			p.SetState(173)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(172)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(175)
				p.Uid()
			}

		}

	case 2:
		localctx = NewSelectFunctionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(178)
			p.FunctionCall()
		}
		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS || (int64((_la-1138)) & ^0x3f) == 0 && ((int64(1)<<(_la-1138))&6145) != 0 {
			p.SetState(180)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(179)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(182)
				p.Uid()
			}

		}

	}

	return localctx
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhereExpr returns the whereExpr rule contexts.
	GetWhereExpr() IExpressionContext

	// SetWhereExpr sets the whereExpr rule contexts.
	SetWhereExpr(IExpressionContext)

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	whereExpr IExpressionContext
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fromClause
	return p
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) GetWhereExpr() IExpressionContext { return s.whereExpr }

func (s *FromClauseContext) SetWhereExpr(v IExpressionContext) { s.whereExpr = v }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FromClauseContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *FromClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *FromClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FromClause() (localctx IFromClauseContext) {
	this := p
	_ = this

	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MySqlParserRULE_fromClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(187)
		p.Match(MySqlParserFROM)
	}
	{
		p.SetState(188)
		p.TableSources()
	}

	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(190)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(191)

			var _x = p.expression(0)

			localctx.(*FromClauseContext).whereExpr = _x
		}

	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitClauseAtomContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitClauseAtomContext

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitClauseAtomContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitClauseAtomContext)

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	offset ILimitClauseAtomContext
	limit  ILimitClauseAtomContext
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetOffset() ILimitClauseAtomContext { return s.offset }

func (s *LimitClauseContext) GetLimit() ILimitClauseAtomContext { return s.limit }

func (s *LimitClauseContext) SetOffset(v ILimitClauseAtomContext) { s.offset = v }

func (s *LimitClauseContext) SetLimit(v ILimitClauseAtomContext) { s.limit = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *LimitClauseContext) AllLimitClauseAtom() []ILimitClauseAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			len++
		}
	}

	tst := make([]ILimitClauseAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitClauseAtomContext); ok {
			tst[i] = t.(ILimitClauseAtomContext)
			i++
		}
	}

	return tst
}

func (s *LimitClauseContext) LimitClauseAtom(i int) ILimitClauseAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LimitClause() (localctx ILimitClauseContext) {
	this := p
	_ = this

	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MySqlParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(194)
		p.Match(MySqlParserLIMIT)
	}
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.SetState(198)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(195)

				var _x = p.LimitClauseAtom()

				localctx.(*LimitClauseContext).offset = _x
			}
			{
				p.SetState(196)
				p.Match(MySqlParserCOMMA)
			}

		}
		{
			p.SetState(200)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}

	case 2:
		{
			p.SetState(201)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}
		{
			p.SetState(202)
			p.Match(MySqlParserOFFSET)
		}
		{
			p.SetState(203)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).offset = _x
		}

	}

	return localctx
}

// ILimitClauseAtomContext is an interface to support dynamic dispatch.
type ILimitClauseAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseAtomContext differentiates from other interfaces.
	IsLimitClauseAtomContext()
}

type LimitClauseAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseAtomContext() *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClauseAtom
	return p
}

func (*LimitClauseAtomContext) IsLimitClauseAtomContext() {}

func NewLimitClauseAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClauseAtom

	return p
}

func (s *LimitClauseAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseAtomContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitClauseAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClauseAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LimitClauseAtom() (localctx ILimitClauseAtomContext) {
	this := p
	_ = this

	localctx = NewLimitClauseAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MySqlParserRULE_limitClauseAtom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(207)
		p.DecimalLiteral()
	}

	return localctx
}

// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullId
	return p
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullId() (localctx IFullIdContext) {
	this := p
	_ = this

	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MySqlParserRULE_fullId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(209)
		p.Uid()
	}
	p.SetState(213)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDOT_ID:
		{
			p.SetState(210)
			p.Match(MySqlParserDOT_ID)
		}

	case MySqlParserDOT:
		{
			p.SetState(211)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(212)
			p.Uid()
		}

	case MySqlParserEOF, MySqlParserFOR, MySqlParserLIMIT, MySqlParserLOCK, MySqlParserSELECT, MySqlParserWHERE, MySqlParserMINUS, MySqlParserCOMMA, MySqlParserSEMI:

	default:
	}

	return localctx
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableName
	return p
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableName() (localctx ITableNameContext) {
	this := p
	_ = this

	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MySqlParserRULE_tableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(215)
		p.FullId()
	}

	return localctx
}

// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnName
	return p
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDottedIdContext); ok {
			len++
		}
	}

	tst := make([]IDottedIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDottedIdContext); ok {
			tst[i] = t.(IDottedIdContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullColumnName() (localctx IFullColumnNameContext) {
	this := p
	_ = this

	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MySqlParserRULE_fullColumnName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(217)
			p.Uid()
		}
		p.SetState(222)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(218)
				p.DottedId()
			}
			p.SetState(220)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(219)
					p.DottedId()
				}

			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(225)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			p.SetState(224)
			p.MatchWildcard()

		}
		{
			p.SetState(227)
			p.DottedId()
		}
		p.SetState(229)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(228)
				p.DottedId()
			}

		}

	}

	return localctx
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_collationName
	return p
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CollationName() (localctx ICollationNameContext) {
	this := p
	_ = this

	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MySqlParserRULE_collationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(235)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(233)
			p.Uid()
		}

	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(234)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_uid
	return p
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Uid() (localctx IUidContext) {
	this := p
	_ = this

	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MySqlParserRULE_uid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(240)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(237)
			p.SimpleId()
		}

	case MySqlParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(238)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
		}

	case MySqlParserCHARSET_REVERSE_QOUTE_STRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(239)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleId
	return p
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SimpleId() (localctx ISimpleIdContext) {
	this := p
	_ = this

	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MySqlParserRULE_simpleId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Match(MySqlParserID)
	}

	return localctx
}

// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dottedId
	return p
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDottedId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DottedId() (localctx IDottedIdContext) {
	this := p
	_ = this

	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MySqlParserRULE_dottedId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(247)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(244)
			p.Match(MySqlParserDOT_ID)
		}

	case MySqlParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(245)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(246)
			p.Uid()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalLiteral
	return p
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	this := p
	_ = this

	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MySqlParserRULE_decimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(249)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1131)) & ^0x3f) == 0 && ((int64(1)<<(_la-1131))&10247) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *StringLiteralContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *StringLiteralContext) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteralContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringLiteralContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MySqlParserRULE_stringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(274)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(256)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(252)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(251)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(254)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(255)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(258)
					p.Match(MySqlParserSTRING_LITERAL)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(261)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(268)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(264)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(263)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(266)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(267)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(272)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(270)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(271)
				p.CollationName()
			}

		}

	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MySqlParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(276)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral
	return p
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHexadecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	this := p
	_ = this

	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MySqlParserRULE_hexadecimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(279)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSTRING_CHARSET_NAME {
		{
			p.SetState(278)
			p.Match(MySqlParserSTRING_CHARSET_NAME)
		}

	}
	{
		p.SetState(281)
		p.Match(MySqlParserHEXADECIMAL_LITERAL)
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MySqlParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(290)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(283)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(284)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(285)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(286)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(287)
			p.HexadecimalLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(288)
			p.BooleanLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(289)
			p.Match(MySqlParserREAL_LITERAL)
		}

	}

	return localctx
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressions
	return p
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Expressions() (localctx IExpressionsContext) {
	this := p
	_ = this

	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MySqlParserRULE_expressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(292)
		p.expression(0)
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(293)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(294)
			p.expression(0)
		}

		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyFrom(ctx *FunctionCallContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AggregateFunctionCallContext struct {
	*FunctionCallContext
}

func NewAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateFunctionCallContext {
	var p = new(AggregateFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateFunctionCallContext) AggregateWindowedFunction() IAggregateWindowedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateWindowedFunctionContext)
}

func (s *AggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MySqlParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewAggregateFunctionCallContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.AggregateWindowedFunction()
	}

	return localctx
}

// IAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type IAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStarArg returns the starArg token.
	GetStarArg() antlr.Token

	// SetStarArg sets the starArg token.
	SetStarArg(antlr.Token)

	// IsAggregateWindowedFunctionContext differentiates from other interfaces.
	IsAggregateWindowedFunctionContext()
}

type AggregateWindowedFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	starArg antlr.Token
}

func NewEmptyAggregateWindowedFunctionContext() *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction
	return p
}

func (*AggregateWindowedFunctionContext) IsAggregateWindowedFunctionContext() {}

func NewAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction

	return p
}

func (s *AggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateWindowedFunctionContext) GetStarArg() antlr.Token { return s.starArg }

func (s *AggregateWindowedFunctionContext) SetStarArg(v antlr.Token) { s.starArg = v }

func (s *AggregateWindowedFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *AggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *AggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateWindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AggregateWindowedFunction() (localctx IAggregateWindowedFunctionContext) {
	this := p
	_ = this

	localctx = NewAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MySqlParserRULE_aggregateWindowedFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Match(MySqlParserCOUNT)
	}
	{
		p.SetState(303)
		p.Match(MySqlParserLR_BRACKET)
	}

	{
		p.SetState(304)

		var _m = p.Match(MySqlParserSTAR)

		localctx.(*AggregateWindowedFunctionContext).starArg = _m
	}

	{
		p.SetState(305)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IsExpressionContext struct {
	*ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }

func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *IsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	*ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }

func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalExpressionContext struct {
	*ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExpressionContext struct {
	*ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPredicateExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *MySqlParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 62
	p.EnterRecursionRule(localctx, 62, MySqlParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(308)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNOT || _la == MySqlParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(309)
			p.expression(4)
		}

	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(310)
			p.predicate(0)
		}
		{
			p.SetState(311)
			p.Match(MySqlParserIS)
		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(312)
				p.Match(MySqlParserNOT)
			}

		}
		{
			p.SetState(315)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE || _la == MySqlParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(317)
			p.predicate(0)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expression)
			p.SetState(320)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(321)
				p.LogicalOperator()
			}
			{
				p.SetState(322)
				p.expression(4)
			}

		}
		p.SetState(328)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExpressionAtomPredicateContext struct {
	*PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *ExpressionAtomPredicateContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *ExpressionAtomPredicateContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *ExpressionAtomPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionAtomPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryComparisonPredicateContext struct {
	*PredicateContext
	left  IPredicateContext
	right IPredicateContext
}

func NewBinaryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparisonPredicateContext {
	var p = new(BinaryComparisonPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BinaryComparisonPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparisonPredicateContext) GetRight() IPredicateContext { return s.right }

func (s *BinaryComparisonPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparisonPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparisonPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BinaryComparisonPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BinaryComparisonPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinaryComparisonPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type InPredicateContext struct {
	*PredicateContext
}

func NewInPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InPredicateContext {
	var p = new(InPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *InPredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *InPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *InPredicateContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *InPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *InPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *InPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *MySqlParser) predicate(_p int) (localctx IPredicateContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 64
	p.EnterRecursionRule(localctx, 64, MySqlParserRULE_predicate, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	p.SetState(332)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(330)
			p.Match(MySqlParserLOCAL_ID)
		}
		{
			p.SetState(331)
			p.Match(MySqlParserVAR_ASSIGN)
		}

	}
	{
		p.SetState(334)
		p.ExpressionAtom()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(349)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparisonPredicateContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(336)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(337)
					p.ComparisonOperator()
				}
				{
					p.SetState(338)

					var _x = p.predicate(3)

					localctx.(*BinaryComparisonPredicateContext).right = _x
				}

			case 2:
				localctx = NewInPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(340)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				p.SetState(342)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(341)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(344)
					p.Match(MySqlParserIN)
				}
				{
					p.SetState(345)
					p.Match(MySqlParserLR_BRACKET)
				}
				{
					p.SetState(346)
					p.Expressions()
				}
				{
					p.SetState(347)
					p.Match(MySqlParserRR_BRACKET)
				}

			}

		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionAtom
	return p
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyFrom(ctx *ExpressionAtomContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *UnaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstantExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstantExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type FullColumnNameExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnNameExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type NestedExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NestedExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNestedExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	this := p
	_ = this

	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MySqlParserRULE_expressionAtom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(354)
			p.Constant()
		}

	case 2:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(355)
			p.FullColumnName()
		}

	case 3:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(356)
			p.UnaryOperator()
		}
		{
			p.SetState(357)
			p.ExpressionAtom()
		}

	case 4:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(359)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(360)
			p.expression(0)
		}
		p.SetState(365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(361)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(362)
				p.expression(0)
			}

			p.SetState(367)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(368)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unaryOperator
	return p
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	this := p
	_ = this

	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MySqlParserRULE_unaryOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNOT || (int64((_la-1113)) & ^0x3f) == 0 && ((int64(1)<<(_la-1113))&387) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MySqlParserRULE_comparisonOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(374)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(375)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(376)
			p.Match(MySqlParserLESS_SYMBOL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(377)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(378)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(379)
			p.Match(MySqlParserGREATER_SYMBOL)
		}
		{
			p.SetState(380)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(381)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(382)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(383)
			p.Match(MySqlParserEXCLAMATION_SYMBOL)
		}
		{
			p.SetState(384)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	}

	return localctx
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_logicalOperator
	return p
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	this := p
	_ = this

	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MySqlParserRULE_logicalOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(393)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(387)
			p.Match(MySqlParserAND)
		}

	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(388)
			p.Match(MySqlParserBIT_AND_OP)
		}
		{
			p.SetState(389)
			p.Match(MySqlParserBIT_AND_OP)
		}

	case MySqlParserOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(390)
			p.Match(MySqlParserOR)
		}

	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(391)
			p.Match(MySqlParserBIT_OR_OP)
		}
		{
			p.SetState(392)
			p.Match(MySqlParserBIT_OR_OP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

func (p *MySqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 31:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 32:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MySqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
